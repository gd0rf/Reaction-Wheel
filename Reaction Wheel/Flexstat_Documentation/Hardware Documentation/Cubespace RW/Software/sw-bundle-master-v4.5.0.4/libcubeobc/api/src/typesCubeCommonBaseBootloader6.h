/************************************************************************************
 * This file was auto-generated by CIDEA                           .                *
 * Please do not modify the contents of this file manually.                         *
 ***********************************************************************************/

#ifndef TYPES_CUBE_COMMON_BASE_BOOTLOADER_6__H
#define TYPES_CUBE_COMMON_BASE_BOOTLOADER_6__H

#include <cubeObc/cubeObc_typeDef.h>
#include <cubeObc/cubeObc_errorDef.h>
#include <cubeObc/cubeObc_tctlmDef.h>

#include "typesCommonFrameworkTypes1.h"
/* PARENT */
#include "typesCubeCommonBaseBootloader5.h"

#ifdef __cplusplus
extern "C" {
#endif

/*******************************************************************************
 *******************************   DEFINES   ***********************************
 ******************************************************************************/

/*******************************************************************************
 *******************************   TYPEDEFS  ***********************************
 ******************************************************************************/

/**
 * @brief Warnings (CubeComputer only) message structure
 * @details Warning information of the application (CubeComputer only)
 */
typedef struct TCTLM_PACKED TypesCubeCommonBaseBootloader6_WarningsStruct {
    Boolean redBinRunning;    /**< The redundant binary is currently running. This implies that the primary binary is corrupt.                                                                                                If this flag is set, a bootloader upgrade should be performed to recover the primary binary.                                                                                                The user must inspect the flags of this telemetry to identify the type of corruption.                                                                                                If this flag is set, the bootloader will not automatically jump to the control program at the end of backoff.                                                                                                The user will need to command the jump manually. This scheme is implemented to enforce user intervention in the case of flash corruption  */
    Boolean redBinIntLock;    /**< This flag is only valid if the redundant binary is running (RedBinRunning=TRUE).                                                                                                If this flag is FALSE, the redundant binary was jumped to after a reset.                                                                                                In this scenario, the redundant bootloader functions as normal and can be upgraded, and the control program can be executed.                                                                                                If this flag is TRUE, the redundant binary was jumped to from an interrupt handler.                                                                                                In this scenario, the redundant bootloader functions as normal and can be upgraded, but the control program cannot be executed.                                                                                                Any attempt to execute the control program will result in an ASSERT reset.                                                                                                This happens because when the redundant bootloader is jumped to from an interrupt handler,                                                                                                the MCU thinks it is still running in an interrupt context, and so the RTOS used by the control program cannot function.                                                                                                Note that for this flag to be TRUE, a very specific area of the primary binary flash must be corrupt (PriBinEccd flag).                                                                                                Therefore, it is very unlikely, however it is implemented so that there is a solution to flash corruption anywhere within the primary binary.  */
    Boolean priBinCrc;        /**< The primary binary has failed CRC validation and is deemed corrupt.                                                                                                The flash itself is not corrupt and can be read, but the CRC validation failed.                                                                                                If this flag is set, the redundant binary should be running (check the RedBinRunning flag).                                                                                                If this flag is set, a bootloader upgrade should be performed to recover the primary binary.                                                                                                If the bootloader is not upgraded, and the redundant binary also becomes corrupt, the bootloader will enter a boot loop cycle.                                                                                                If this flag is set, the bootloader will not automatically jump to the control program at the end of backoff.                                                                                                The user will need to command the jump manually. This scheme is implemented to enforce user intervention in the case of flash corruption  */
    Boolean priBinEccd;       /**< The primary binary flash region has experienced multiple ECC errors and cannot be automatically corrected, and is corrupt.                                                                                                Multiple ECC errors means that the flash region can no longer be read and therefore cannot be executed reliably.                                                                                                If this flag is set, the redundant binary should be running (check the RedBinRunning flag).                                                                                                If this flag is set, a bootloader upgrade should be performed to recover the primary binary.                                                                                                If the bootloader is not upgraded, and the redundant binary also becomes corrupt, the bootloader will enter a boot loop cycle.                                                                                                If this flag is set, the bootloader will not automatically jump to the control program at the end of backoff.                                                                                                The user will need to command the jump manually. This scheme is implemented to enforce user intervention in the case of flash corruption  */
    Boolean priBinEccc;       /**< The primary binary flash region has experienced a single ECC error.                                                                                                The error is automatically corrected and normal operation continues  */
    Boolean redBinCrc;        /**< The redundant binary has failed CRC validation and is deemed corrupt.                                                                                                The flash itself is not corrupt and can be read, but the CRC validation failed.                                                                                                If this flag is set, a bootloader upgrade should be performed to recover the redundant binary.                                                                                                If the bootloader is not upgraded, and the primary binary also becomes corrupt, the bootloader will enter a boot loop cycle.                                                                                                If this flag is set, the bootloader will not automatically jump to the control program at the end of backoff.                                                                                                The user will need to command the jump manually. This scheme is implemented to enforce user intervention in the case of flash corruption  */
    Boolean redBinEccd;       /**< The Redundant binary flash region has experienced multiple ECC errors and cannot be automatically corrected, and is corrupt.                                                                                                Multiple ECC errors means that the flash region can no longer be read and therefore cannot be executed reliably.                                                                                                If this flag is set, a bootloader upgrade should be performed to recover the redundant binary.                                                                                                If the bootloader is not upgraded, and the primary binary also becomes corrupt, the bootloader will enter a boot loop cycle.                                                                                                If this flag is set, the bootloader will not automatically jump to the control program at the end of backoff.                                                                                                The user will need to command the jump manually. This scheme is implemented to enforce user intervention in the case of flash corruption  */
    Boolean redBinEccc;       /**< The Redundant binary flash region has experienced a single ECC error.                                                                                                The error is automatically corrected and normal operation continues  */
    Boolean priCfgCrc;        /**< The primary config has failed CRC validation and is deemed corrupt.                                                                                                The flash itself is not corrupt and can be read, but the CRC validation failed.                                                                                                If the redundant config is not corrupt, the redundant config is being used.                                                                                                If the redundant config is also corrupt, the default config is being used.                                                                                                The user should set the config manually too attempt to write both the primary and redundant to flash.                                                                                                If this flag is set, the bootloader will not automatically jump to the control program at the end of backoff.                                                                                                The user will need to command the jump manually. This scheme is implemented to enforce user intervention in the case of flash corruption  */
    Boolean priCfgEccd;       /**< The primary config has experienced multiple ECC errors and cannot be automatically corrected, and is corrupt.                                                                                                Multiple ECC errors means that the flash region can no longer be read.                                                                                                If the redundant config is not corrupt, the redundant config is being used.                                                                                                If the redundant config is also corrupt, the default config is being used.                                                                                                The user should set the config manually too attempt to write both the primary and redundant to flash.                                                                                                If this flag is set, the bootloader will not automatically jump to the control program at the end of backoff.                                                                                                The user will need to command the jump manually. This scheme is implemented to enforce user intervention in the case of flash corruption  */
    Boolean priCfgEccc;       /**< The primary config flash region has experienced a single ECC error. The error is automatically corrected and normal operation continues  */
    Boolean redCfgCrc;        /**< The redundant config has failed CRC validation and is deemed corrupt.                                                                                                The flash itself is not corrupt and can be read, but the CRC validation failed.                                                                                                If the primary config is not corrupt, the primary config is being used.                                                                                                If the primary config is also corrupt, the default config is being used.                                                                                                The user should set the config manually too attempt to write both the primary and redundant to flash.                                                                                                If this flag is set, the bootloader will not automatically jump to the control program at the end of backoff.                                                                                                The user will need to command the jump manually. This scheme is implemented to enforce user intervention in the case of flash corruption  */
    Boolean redCfgEccd;       /**< The redundant config has experienced multiple ECC errors and cannot be automatically corrected, and is corrupt.                                                                                                Multiple ECC errors means that the flash region can no longer be read.                                                                                                If the primary config is not corrupt, the primary config is being used.                                                                                                If the primary config is also corrupt, the default config is being used.                                                                                                The user should set the config manually too attempt to write both the primary and redundant to flash.                                                                                                If this flag is set, the bootloader will not automatically jump to the control program at the end of backoff.                                                                                                The user will need to command the jump manually. This scheme is implemented to enforce user intervention in the case of flash corruption  */
    Boolean redCfgEccc;       /**< The redundant config flash region has experienced a single ECC error. The error is automatically corrected and normal operation continues  */
    Boolean fileTabEccd;      /**< The file table flash region has experienced multiple ECC errors and cannot be automatically corrected, and is corrupt.                                                                                                Multiple ECC errors means that the flash region can no longer be read.                                                                                                The flash page is automatically erased, therefore control program files will need to be uploaded again to populate the file table.                                                                                                Note that the file data still exists in flash, and could be executed using the JumpToAddress command  */
    Boolean fileTabEccc;      /**< The file table flash region has experienced a single ECC error. The error is automatically corrected and normal operation continues  */
    Boolean otherEccd;        /**< A flash region not explicitly known to the bootloader (possibly the control program),                                                                                                has experienced multiple ECC errors and cannot be automatically corrected, and has become corrupt.                                                                                                Multiple ECC errors means that the flash region can no longer be read.                                                                                                The page address of the error is automatically erased. The address of the error is stored in AddrEcc  */
    Boolean otherEccc;        /**< A region not explicitly known to the bootloader (possibly the control program) has experianced a single ECC error.                                                                                                The error is automatically corrected and normal operation continues. The address of the error is stored in AddrEcc  */
    Boolean eraseEccd;        /**< Attempt to erase the corrupt flash page failed.                                                                                                When any flash region, outside of the bootloader itself, experiences multiple ECC errors (ECCD),                                                                                                The page is automatically erased. This flag indicates if that erase operation failed.                                                                                                The address of the error is stored in AddrEcc  */
    Boolean cfgPartInv;       /**< The config being used passed CRC validation but at least one parameter is out-of-bounds.                                                                                                The config being used is either primary or redundant, and is decided prior to this check.                                                                                                The check for out out-of-bounds parameters is only done after a valid config is chosen,                                                                                                because, for example, if the primary config has an out-of-bounds parameter and passes CRC validation,                                                                                                it is likely that the redundant config will have the same parameter,                                                                                                and we don't want one out-of-bounds parameter to cause the bootloader to entirely revert to the default config.                                                                                                We rather only revert the specific out-of-bounds parameters to the defaults, and hope the important/used parameters are correct.                                                                                                The same parameter out-of-bounds checks are performed when the user sets the config,                                                                                                therefore it is unlikely that this flag will be set.  */
    Boolean redCfgWrite;      /**< Failed to write the redundant config to flash after the primary config was successfully written.                                                                                                The redundant config is only written to flash if the primary config was successfully written to flash.                                                                                                It is done this way because if the primary config write fails, we do not want to erase the redundant config,                                                                                                because if the redundant config write also fails, but is erased, the bootloader would revert to the default config on next boot  */
    U32 addrEcc;              /**< Address of last ECC error (ECCC or ECCD).                                                                                                This is an absolute address and does not cater for memory remapping.                                                                                                i.e. If booting from bank2 (BFB2=1), this address will still show the error location as if BFB2=0  */
} TypesCubeCommonBaseBootloader6_Warnings;

/**
 * @brief Simulate ECC Error message structure
 * @details Simulate an ECC correction/error
 */
typedef struct TCTLM_PACKED TypesCubeCommonBaseBootloader6_EccSimStruct {
    U32 magicNumber;           /**< Magic number to allow action  */
    U32 addr;                  /**< The offset within the specified bank that the error occured at  */
    Boolean bank;              /**< The flash bank the error occured in (0=bank1, 1=bank2)  */
    Boolean eccd;              /**< Double ECC error  */
    Boolean eccc;              /**< Single ECC error  */
    Boolean bootIncomplete;    /**< If a double ECC error occurs in the primary image,                                                                                  the action taken depends on this flag.                                                                                  If this flag is FALSE, an ECC error will result in a reset and then immediate jump to the redundant image.                                                                                  If this flag is TRUE, it means the reset approach is not possible because the code to jump to the redundant image is unreachable,                                                                                  therefore we jump to the redundant image in the interrupt handler;                                                                                  this type of jump has consequences, as the MCU thinks that the interrupt handler never returned;                                                                                  mitigations have been put in place such that if this does occur during normal operation,                                                                                  both the redundant bootloader and the control program can still execute.  */
} TypesCubeCommonBaseBootloader6_EccSim;

/*******************************************************************************
 *****************************   PROTOTYPES   **********************************
 ******************************************************************************/

#ifdef __cplusplus
}
#endif

#endif // TYPES_CUBE_COMMON_BASE_BOOTLOADER_6_H
