/************************************************************************************
 * This file was auto-generated by CIDEA                           .                *
 * Please do not modify the contents of this file manually.                         *
 ***********************************************************************************/

#ifndef TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__H
#define TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__H

#include <cubeObc/cubeObc_typeDef.h>
#include <cubeObc/cubeObc_errorDef.h>
#include <cubeObc/cubeObc_tctlmDef.h>

#include "typesCommonFramework1.h"
#include "typesCubeComputerCommon3.h"
#include "typesCommonFrameworkTypes1.h"

#ifdef __cplusplus
extern "C" {
#endif

/*******************************************************************************
 *******************************   DEFINES   ***********************************
 ******************************************************************************/

/*******************************************************************************
 *******************************   TYPEDEFS  ***********************************
 ******************************************************************************/

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_AdcsRunModeSelect
*/
typedef enum TypesCubeComputerControlProgram8_AdcsRunModeSelectEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ADCS_OFF = 0,           /**< ADCS loop is inactive */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ADCS_ENABLED = 1,       /**< ADCS loop is active */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ADCS_TRIGGERED = 2,     /**< ADCS loop executed on trigger */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ADCS_SIMULATION = 3,    /**< ADCS is in simulation mode */
} TypesCubeComputerControlProgram8_AdcsRunModeSelect;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_AdcsOpStateSelect
*/
typedef enum TypesCubeComputerControlProgram8_AdcsOpStateSelectEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OP_STATE_MANUAL = 0,    /**< Manual operational state */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OP_STATE_AUTO = 1,      /**< Autonomous operational state */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OP_STATE_SAFE = 2,      /**< Safe operational state */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OP_STATE_FAULT = 3,     /**< Fault operational state */
} TypesCubeComputerControlProgram8_AdcsOpStateSelect;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_EstSelect
*/
typedef enum TypesCubeComputerControlProgram8_EstSelectEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_MAIN = 0,      /**< EstMain */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_BACKUP = 1,    /**< EstBackup */
} TypesCubeComputerControlProgram8_EstSelect;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_EstModeSelect
*/
typedef enum TypesCubeComputerControlProgram8_EstModeSelectEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_NONE = 0,         /**< No estimator */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_GYRO = 1,         /**< Gyro measured rates */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_MAG_RKF = 2,      /**< Magnetometer estimated rates */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_PITCH_RKF = 3,    /**< Magnetometer estimated rates with pitch estimation */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_TRIAD = 4,        /**< Triad attitude estimation plus gyro rates */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_FULL_EKF = 5,     /**< Full state EKF */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_GYRO_EKF = 6,     /**< Gyro EKF for attitude and gyro bias estimation */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_USER = 100,       /**< User coded estimator */
} TypesCubeComputerControlProgram8_EstModeSelect;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_ConModeSelect
*/
typedef enum TypesCubeComputerControlProgram8_ConModeSelectEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_NONE = 0,                /**< No control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_BDOT = 1,                /**< Single axis Bdot for detumbling */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_YSPIN = 2,               /**< Y-Thomson spin */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_BDOT_3 = 3,              /**< 3-axis Bdot detumbling */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_DETUMBLE = 4,            /**< 3-axis low power detumbling */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_SUN_YSPIN = 5,           /**< Sun Y-axis spin detumbling */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_ZSPIN = 6,               /**< Z-Thomson spin */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_SUN_ZSPIN = 7,           /**< Sun Z-axis spin detumbling */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_GGBOOM = 8,              /**< Mag control of GG boom and yaw zero control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_GGSUN = 9,               /**< Mag control of GG boom and Z-RW yaw sun pointing */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_YWHEEL_INIT = 10,        /**< Initial Y-wheel ramp to Y-Wheel control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_YWHEEL = 11,             /**< Y-wheel pitch control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_XYZWHEEL = 12,           /**< 3-axis reaction wheel control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_SUN_TRACK = 13,          /**< RW sun tracking control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_TGT_TRACK = 14,          /**< RW EO target tracking control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_TGT_STEER = 15,          /**< RW Earth target steering control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_GND_TRACK = 16,          /**< RW G/S target tracking control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_IRC_TRACK = 17,          /**< RW Inertial target tracking control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_MOON_TRACK = 18,         /**< RW moon tracking control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_SAT_TRACK = 19,          /**< RW satellite target tracking control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_YAW_SUN = 20,            /**< Nadir pointing and yaw towards the sun */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_YAW_TARGET = 21,         /**< Nadir pointing and yaw towards ground target */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_ROLL_SUN = 22,           /**< Velocity pointing and roll towards the sun */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_ROLL_TARGET = 23,        /**< Velocity pointing and roll towards ground target */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_YAW_TARGET_BEST = 24,    /**< Nadir pointing and yaw best +/-Y body axis to G/S */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_FMC_TARGET = 25,         /**< Forward Motion Compensation to scan target using +Z body axis */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_YAW_SUN_SPIN = 26,       /**< RW sun yaw-spin control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_SUN_DETUMBLE = 27,       /**< RW detumbling to sun-pointing control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_ASTRO_STEER = 28,        /**< RW astronomical target tracking/steering with Zenith axis */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_SUN_PAYLOAD = 29,        /**< RW sun tracking and rotation for payload pointing to Zenith */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_STOP_RW = 50,            /**< Controlled stop of RWs */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_HXYZ_RW = 51,            /**< Open loop XYZ RW momentum command control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_USER = 100,              /**< User coded control mode */
} TypesCubeComputerControlProgram8_ConModeSelect;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_OrbModeSelect
*/
typedef enum TypesCubeComputerControlProgram8_OrbModeSelectEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ORB_TLE = 0,           /**< Orbit calculated from SGP4 TLEs only */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ORB_TLE_GNSS = 1,      /**< Orbit calculated from SGP4 TLE but replaced with GNSS measurements if available */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ORB_ASGP_4 = 2,        /**< Orbit calculated from Augmented SGP4 TLE */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ORB_ASGP4_GNSS = 3,    /**< Orbit calculated from Augmented SGP4 TLE but replaced with GNSS measurements if available */
} TypesCubeComputerControlProgram8_OrbModeSelect;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_NavSource
*/
typedef enum TypesCubeComputerControlProgram8_NavSourceEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__NAV_GNSS_NOW = 0,           /**< Reported position and velocity (in TlmModels) comes from direct (latest) GNSS measurement */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__NAV_GNSS_PROPAGATED = 1,    /**< Reported position and velocity (in TlmModels) comes from GNSS measurement up to 800ms old, propagated using linear velocity */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__NAV_TLE = 2,                /**< Reported position and velocity (in TlmModels) comes from SGP4 with orbital elements set via ConfigOrbitSatParams (from TLEs) */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__NAV_ASGP4_TLE = 3,          /**< Reported position and velocity (in TlmModels) comes from ASGP4 with orbital elements that were adjusted from GNSS measurements */
} TypesCubeComputerControlProgram8_NavSource;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_FmcStage
*/
typedef enum TypesCubeComputerControlProgram8_FmcStageEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_INACTIVE = 0,         /**< FMC control mode is not selected */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_WAITING = 1,          /**< Waiting for FMC scan to start. (defaults to same control as ConXYZwheel) */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_PREPARE = 2,          /**< Control to FMC roll offset, and zero pitch and yaw */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_INITIAL_PITCH = 3,    /**< Control initial FMC pitch angle for scan start */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_RW_RAMP_UP = 4,       /**< RW ramp for 10 sec towards FMC rate */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_SCAN = 5,             /**< FMC scan for 60s */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_RW_RAMP_DOWN = 6,     /**< Ramp Pitch RW for 10 sec back to FMC1 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_STOPPING = 7,         /**< Stop FMC control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_ENDED = 8,            /**< FMC scan ended. (defaults to same control as ConXYZwheel) */
} TypesCubeComputerControlProgram8_FmcStage;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_VecSelect
*/
typedef enum TypesCubeComputerControlProgram8_VecSelectEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__VEC_MAG = 0,    /**< Select magnetometer vector */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__VEC_FSS = 1,    /**< Select fine sun sensor vector */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__VEC_CSS = 2,    /**< Select coarse sun sensor vector */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__VEC_HSS = 3,    /**< Select horizon (nadir) vector */
} TypesCubeComputerControlProgram8_VecSelect;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_FmcFactor
*/
typedef enum TypesCubeComputerControlProgram8_FmcFactorEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_2 = 0,    /**< Forward Motion Compensation Factor 2 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_4 = 1,    /**< Forward Motion Compensation Factor 4 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FMC_8 = 2,    /**< Forward Motion Compensation Factor 8 */
} TypesCubeComputerControlProgram8_FmcFactor;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_AxisSelect
*/
typedef enum TypesCubeComputerControlProgram8_AxisSelectEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_NOT_USED = 0,    /**< Not Used */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_POS_X = 1,       /**< Positive X */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_NEG_X = 2,       /**< Negative X */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_POS_Y = 3,       /**< Positive Y */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_NEG_Y = 4,       /**< Negative Y */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_POS_Z = 5,       /**< Positive Z */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_NEG_Z = 6,       /**< Negative Z */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_THD_A = 7,       /**< Tetrahedral A */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_THD_B = 8,       /**< Tetrahedral B */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_THD_C = 9,       /**< Tetrahedral C */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_THD_D = 10,      /**< Tetrahedral D */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_PMD_A = 11,      /**< Pyramid A */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_PMD_B = 12,      /**< Pyramid B */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_PMD_C = 13,      /**< Pyramid C */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_PMD_D = 14,      /**< Pyramid D */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AXIS_SKEW = 15,       /**< Skewed 4th wheel at PosXYZ */
} TypesCubeComputerControlProgram8_AxisSelect;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_RwlScheme
*/
typedef enum TypesCubeComputerControlProgram8_RwlSchemeEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__RWL_SCHEME_NO_WHEELS = 0,      /**< RwlSchemeNoWheels */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__RWL_SCHEME_YMOMENTUM = 1,      /**< RwlSchemeYMomentum */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__RWL_SCHEME_XYZ = 2,            /**< RwlSchemeXYZ */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__RWL_SCHEME_PYRAMID = 3,        /**< RwlSchemePyramid */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__RWL_SCHEME_TETRAHEDRAL = 4,    /**< RwlSchemeTetrahedral */
} TypesCubeComputerControlProgram8_RwlScheme;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_RwlFailId
*/
typedef enum TypesCubeComputerControlProgram8_RwlFailIdEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__RWL_FAIL_NONE = 0,    /**< RwlFailNone */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__RWL_FAIL_0 = 1,       /**< RwlFail0 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__RWL_FAIL_1 = 2,       /**< RwlFail1 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__RWL_FAIL_2 = 3,       /**< RwlFail2 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__RWL_FAIL_3 = 4,       /**< RwlFail3 */
} TypesCubeComputerControlProgram8_RwlFailId;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_WheelId
*/
typedef enum TypesCubeComputerControlProgram8_WheelIdEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_WHEEL_0 = 0,    /**< CubeWheel0 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_WHEEL_1 = 1,    /**< CubeWheel1 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_WHEEL_2 = 2,    /**< CubeWheel2 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_WHEEL_3 = 3,    /**< CubeWheel3 */
} TypesCubeComputerControlProgram8_WheelId;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_SensorId
*/
typedef enum TypesCubeComputerControlProgram8_SensorIdEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_MAG_0 = 0,             /**< CubeMag0 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_MAG_1 = 1,             /**< CubeMag1 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_SENSE_SUN_0 = 2,       /**< CubeSenseSun0 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_SENSE_SUN_1 = 3,       /**< CubeSenseSun1 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_SENSE_SUN_2 = 4,       /**< CubeSenseSun2 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_SENSE_SUN_3 = 5,       /**< CubeSenseSun3 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_SENSE_EARTH_0 = 6,     /**< CubeSenseEarth0 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_SENSE_EARTH_1 = 7,     /**< CubeSenseEarth1 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_STAR_0 = 8,            /**< CubeStar0 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_STAR_1 = 9,            /**< CubeStar1 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXT_STAR_TRACKER_0 = 10,    /**< ExtStarTracker0 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXT_STAR_TRACKER_1 = 11,    /**< ExtStarTracker1 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXT_SENSOR_0 = 12,          /**< ExtSensor0 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXT_SENSOR_1 = 13,          /**< ExtSensor1 */
} TypesCubeComputerControlProgram8_SensorId;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_AcpExecutionPoint
*/
typedef enum TypesCubeComputerControlProgram8_AcpExecutionPointEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXEC_POINT_INIT = 0,               /**< Initialisation */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXEC_POINT_IDLE = 1,               /**< Idle */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXEC_POINT_SENSOR_COMMS = 2,       /**< Sensor communication */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXEC_POINT_ADCS_ESTIMATION = 3,    /**< ADCS estimation update */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXEC_POINT_ADCS_CONTROLLER = 4,    /**< ADCS controller update */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXEC_POINT_WHEEL_COMMS = 5,        /**< Reaction wheel communication */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXEC_POINT_ADCS_MODELS = 6,        /**< ADCS models update */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXEC_POINT_HOUSEKEEPING = 7,       /**< Housekeeping */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EXEC_POINT_TLM_LOG = 8,            /**< Telemetry logging */
} TypesCubeComputerControlProgram8_AcpExecutionPoint;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_ConModeNotAllowedReason
*/
typedef enum TypesCubeComputerControlProgram8_ConModeNotAllowedReasonEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_MODE_NOT_ALLOW_CON_EST_COMBO = 1,    /**< Invalid control/estimation combination */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_MODE_NOT_ALLOW_ACT = 2,              /**< Actuators not compatible with mode */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_MODE_NOT_ALLOW_INIT_COND = 3,        /**< Invalid initial conditions */
} TypesCubeComputerControlProgram8_ConModeNotAllowedReason;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_EstModeNotAllowedReason
*/
typedef enum TypesCubeComputerControlProgram8_EstModeNotAllowedReasonEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_MODE_NOT_ALLOW_CON_EST_COMBO = 1,    /**< Invalid control/estimation combination */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_MODE_NOT_ALLOW_SEN = 2,              /**< Sensors not compatible with mode */
} TypesCubeComputerControlProgram8_EstModeNotAllowedReason;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_ConModeChangeReason
*/
typedef enum TypesCubeComputerControlProgram8_ConModeChangeReasonEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_CHANGE_CMD = 1,            /**< Commanded change in control mode */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_CHANGE_MAG_TIMEOUT = 2,    /**< Magnetic control timeout */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CON_CHANGE_GYRO_ERROR = 3,     /**< Gyro measurement error while using GyroEkf estimator and wheel control */
} TypesCubeComputerControlProgram8_ConModeChangeReason;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_EstModeChangeReason
*/
typedef enum TypesCubeComputerControlProgram8_EstModeChangeReasonEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_CHANGE_CMD = 1,           /**< Commanded change in estimation mode */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EST_CHANGE_GYRO_ERROR = 2,    /**< Gyro measurement error while using GyroEKF or Gyro rate estimator */
} TypesCubeComputerControlProgram8_EstModeChangeReason;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_AdcsConfigChangeType
*/
typedef enum TypesCubeComputerControlProgram8_AdcsConfigChangeTypeEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_MOUNTING = 0,       /**< Mounting configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_MAG0_CALIB = 1,     /**< Mag0 magnetometer in-orbit calibration configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_MAG1_CALIB = 2,     /**< Mag1 magnetometer in-orbit calibration configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_CONTROLLER = 3,     /**< ADCS controller configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_ESTIMATOR = 4,      /**< ADCS estimator configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_SATELLITE = 5,      /**< ADCS satellite configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_SAT_ORBIT = 6,      /**< Satellite orbit parameter configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_TGT_ORBIT = 7,      /**< Target satellite orbit parameter configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_NODE_SELECT = 8,    /**< Node selection configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_ACT_RWL = 9,        /**< wheel configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_ACT_MTQ = 10,       /**< Magnetorquer configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_CHANGE_ASGP_4 = 11,        /**< ASGP4 configuration */
} TypesCubeComputerControlProgram8_AdcsConfigChangeType;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_AdcsConfigValidationError
*/
typedef enum TypesCubeComputerControlProgram8_AdcsConfigValidationErrorEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_ERR_STACK_MNT = 0,      /**< Error in stack mounting configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_ERR_MTQ_MNT = 1,        /**< Error in magnetorquer mounting configuration */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_ERR_WHL_MNT = 2,        /**< Wheel mounting configuration not allowed */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_ERR_MAG0_SENS = 3,      /**< Mag0 sensitivity matrix elements out of range */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_ERR_MAG1_SENS = 4,      /**< Mag1 sensitivity matrix elements out of range */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_ERR_MO_I = 5,           /**< Moments of inertia out of range */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_ERR_PO_I = 6,           /**< Products of inertia ratio out of range */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_ERR_SAT_ORB = 7,        /**< Satellite orbit parameter error */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_ERR_TGT_ORB = 8,        /**< Target satellite orbit parameter error */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_ERR_RWL_PARAMS = 9,     /**< Wheel parameters out of range */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG_ERR_MTQ_PARAMS = 10,    /**< Magnetorquer parameters out of range */
} TypesCubeComputerControlProgram8_AdcsConfigValidationError;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_LoopFailureContext
*/
typedef enum TypesCubeComputerControlProgram8_LoopFailureContextEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__LOOP_SYNC_TIMEOUT_START = 0,      /**< Control loop sync timeout at start of configuration of loop period */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__LOOP_SYNC_TIMEOUT_RUNTIME = 1,    /**< Control loop sync timeout during runtime */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__LOOP_OVERRUN = 2,                 /**< Control loop overrun */
} TypesCubeComputerControlProgram8_LoopFailureContext;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_LoopCriticalContext
*/
typedef enum TypesCubeComputerControlProgram8_LoopCriticalContextEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CRITICAL_LOOP_SYNC = 0,       /**< Control loop critical failure state due to multiple consecutive syncronization timeouts */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CRITICAL_LOOP_OVERRUN = 1,    /**< Control loop critical failure state due to multiple consecutive overruns */
} TypesCubeComputerControlProgram8_LoopCriticalContext;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_MtqPolarity
*/
typedef enum TypesCubeComputerControlProgram8_MtqPolarityEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__MTQ_OFF = 0,         /**< Magnetorquer is off */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__MTQ_POSITIVE = 1,    /**< Magnetorquer is on with positive polarity */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__MTQ_NEGATIVE = 2,    /**< Magnetorquer is on with negative polarity */
} TypesCubeComputerControlProgram8_MtqPolarity;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_GyroErrorContext
*/
typedef enum TypesCubeComputerControlProgram8_GyroErrorContextEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__GYRO_DRDY_TIMEOUT = 0,    /**< The gyro did not signal data-ready in time */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__GYRO_SAMPLE = 1,          /**< Failure to sample the gyro */
} TypesCubeComputerControlProgram8_GyroErrorContext;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_GyroCriticalContext
*/
typedef enum TypesCubeComputerControlProgram8_GyroCriticalContextEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__GYRO_DRIVER_SETUP = 0,    /**< Low-level driver setup failed */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__GYRO_DRDY_SETUP = 1,      /**< Data ready gpio setup failed */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__GYRO_CONFIGURE = 2,       /**< Failed to configure the gyro */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__GYRO_COMATOSE = 3,        /**< The gyro has experience multiple, consecutive errors (GyroErrorContext) and is presumed unusable */
} TypesCubeComputerControlProgram8_GyroCriticalContext;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_InitState
*/
typedef enum TypesCubeComputerControlProgram8_InitStateEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__INIT_OFF = 0,        /**< Node is powered off */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__INIT_JUMP = 1,       /**< Node is being commanded to jump to its control-program */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__INIT_SETUP = 2,      /**< Node control-program setup in progress */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__INIT_DONE = 3,       /**< Node initialization is complete. The control-program is running and ready for control */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__INIT_PASS = 4,       /**< Node is powered on for passthrough and is not performing any tasks */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__INIT_UPGRADE = 5,    /**< Node is being used for upgrade - note that is any node bootloader is being upgraded, all nodes will be used since the whole bus is needed */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__INIT_MAX = 6,        /**< Enumeration max value (invalid) */
} TypesCubeComputerControlProgram8_InitState;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_CqAssign
*/
typedef enum TypesCubeComputerControlProgram8_CqAssignEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ASSIGN_NONE = 0,     /**< Nothing assigned to CubeNode-Quad port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ASSIGN_STR_0 = 1,    /**< Assign STR0 to CubeNode-Quad port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ASSIGN_STR_1 = 2,    /**< Assign STR1 to CubeNode-Quad port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ASSIGN_RWL_0 = 3,    /**< Assign RWL0 to CubeNode-Quad port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ASSIGN_RWL_1 = 4,    /**< Assign RWL1 to CubeNode-Quad port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ASSIGN_RWL_2 = 5,    /**< Assign RWL2 to CubeNode-Quad port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ASSIGN_RWL_3 = 6,    /**< Assign RWL3 to CubeNode-Quad port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ASSIGN_GYR_X = 7,    /**< Assign External GYR X-axis to CubeNode-Quad port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ASSIGN_GYR_Y = 8,    /**< Assign External GYR X-axis to CubeNode-Quad port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ASSIGN_GYR_Z = 9,    /**< Assign External GYR X-axis to CubeNode-Quad port */
} TypesCubeComputerControlProgram8_CqAssign;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_Pst3sVersion
*/
typedef enum TypesCubeComputerControlProgram8_Pst3sVersionEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PST3S_VERSION_G2 = 0,    /**< PSST3S Version G2 */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PST3S_VERSION_H3 = 1,    /**< PSST3S Version H3 */
} TypesCubeComputerControlProgram8_Pst3sVersion;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_Pst3sDynamicMode
*/
typedef enum TypesCubeComputerControlProgram8_Pst3sDynamicModeEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__DYNAMIC_MODE_INVALID = 0,    /**< Invalid Dynamic Mode. Depends on PST3S version. */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__DYNAMIC_MODE_HIGH = 1,       /**< High Dynamic Mode */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__DYNAMIC_MODE_LOW = 2,        /**< Low Dynamic Mode */
} TypesCubeComputerControlProgram8_Pst3sDynamicMode;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_Pst3sSaaWorkingMode
*/
typedef enum TypesCubeComputerControlProgram8_Pst3sSaaWorkingModeEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SAA_INVALID = 0,     /**< SAA Invalid. Depends on PST3S version. */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SAA_OFF = 1,         /**< SAA Off */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SAA_TRACKING = 2,    /**< SAA On when Tracking */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SAA_CAPTURE = 3,     /**< SAA on when Capture */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SAA_ALL = 4,         /**< SAA on when Tracking and Capture */
} TypesCubeComputerControlProgram8_Pst3sSaaWorkingMode;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_Pst3sOperatingModes
*/
typedef enum TypesCubeComputerControlProgram8_Pst3sOperatingModesEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__MODE_INVALID = 0,       /**< Invalid Mode */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__NORMAL_MODE = 1,        /**< Normal Mode */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FIXED_THRESHOLD = 2,    /**< Fixed Threshold */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SELF_TEST = 3,          /**< Self-Test Mode */
} TypesCubeComputerControlProgram8_Pst3sOperatingModes;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_Pst3sQuaternionFilteringGetState
*/
typedef enum TypesCubeComputerControlProgram8_Pst3sQuaternionFilteringGetStateEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__QFILTERING_GET_INVALID = 0,    /**< Filtering Invalid. Depends on PST3S version. */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__QFILTERING_GET_OFF = 1,        /**< Filtering Off */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__QFILTERING_GET_ON = 2,         /**< Filtering On */
} TypesCubeComputerControlProgram8_Pst3sQuaternionFilteringGetState;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_Pst3sSelfTestResult
*/
typedef enum TypesCubeComputerControlProgram8_Pst3sSelfTestResultEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CORRECT = 0,    /**< Selt-test OK */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ERROR = 1,      /**< Selt-test Error */
} TypesCubeComputerControlProgram8_Pst3sSelfTestResult;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_Pst3sDataValid
*/
typedef enum TypesCubeComputerControlProgram8_Pst3sDataValidEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__GESTURE_VALID = 0,     /**< Gesture Data Valid */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ATTITUDE_VALID = 1,    /**< Attitude Data Valid */
} TypesCubeComputerControlProgram8_Pst3sDataValid;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_Pst3sExtImageState
*/
typedef enum TypesCubeComputerControlProgram8_Pst3sExtImageStateEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__IMAGE_INVALID = 0,    /**< External Image State Invalid for API version */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__IMAGE_OFF = 1,        /**< External Image State Off */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__IMAGE_ON = 2,         /**< External Image State On */
} TypesCubeComputerControlProgram8_Pst3sExtImageState;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_Pst3sRateQuality
*/
typedef enum TypesCubeComputerControlProgram8_Pst3sRateQualityEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__RATE_INVALID = 0,    /**< Invalid - no velocity information */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ESTIMATED = 1,       /**< Velocity is estimated from previous calculations */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PRECISE = 2,         /**< Velocity is precise and calculated from attitude data */
} TypesCubeComputerControlProgram8_Pst3sRateQuality;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_SunDetectResult
*/
typedef enum TypesCubeComputerControlProgram8_SunDetectResultEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SUN_DET_STARTUP = 0,    /**< Initialized */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SUN_NO_DETECT = 1,      /**< Nothing Detected */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SUN_DET_PENDING = 2,    /**< Pending a result */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SUN_NOT_FOUND = 6,      /**< No Sun found */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SUN_SUCCESS = 7,        /**< Sun detected */
} TypesCubeComputerControlProgram8_SunDetectResult;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_SunCaptureResult
*/
typedef enum TypesCubeComputerControlProgram8_SunCaptureResultEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SUN_CAP_STARTUP = 0,                /**< Initialized */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SUN_CAP_PENDING = 1,                /**< Issued but not complete */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SUN_CAPTURE_SUCCESS_NORMAL = 2,     /**< Successful capture */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SUN_TIMEOUT = 3,                    /**< Response Timeout */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SUN_SRAMERR = 4,                    /**< Overcurrent Detected */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SUN_CAPTURE_SUCCESS_FLIPPED = 5,    /**< Successful capture but result flipped */
} TypesCubeComputerControlProgram8_SunCaptureResult;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_EarthDetectResult
*/
typedef enum TypesCubeComputerControlProgram8_EarthDetectResultEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EARTH_DET_STARTUP = 0,      /**< Initialized */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EARTH_DET_PENDING = 1,      /**< Pending a result */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EARTH_NO_HORIZON = 2,       /**< No horizon detected in field of view */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EARTH_TOO_FEW_EDGES = 3,    /**< Not enough edge points detected */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EARTH_BAD_FIT = 4,          /**< Failed to fit shape on horizon */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EARTH_SUCCESS = 5,          /**< Horizon detected */
} TypesCubeComputerControlProgram8_EarthDetectResult;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_EarthCaptureResult
*/
typedef enum TypesCubeComputerControlProgram8_EarthCaptureResultEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EARTH_CAP_STARTUP = 0,    /**< Initialized */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EARTH_CAP_PENDING = 1,    /**< Issued but not complete */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EARTH_CAP_SUCCESS = 2,    /**< Successful capture */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EARTH_CAP_TIMEOUT = 3,    /**< Response Timeout */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__EARTH_CAP_ERROR = 4,      /**< Capture driver error */
} TypesCubeComputerControlProgram8_EarthCaptureResult;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_StarCaptureStatus
*/
typedef enum TypesCubeComputerControlProgram8_StarCaptureStatusEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_CAPTURE_STARTUP = 0,    /**< Initialised */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_CAPTURE_PENDING = 1,    /**< Image capture scheduled */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_CAPTURE_BUSY = 2,       /**< Image capture in progress */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_CAPTURE_DONE = 3,       /**< Successful capture */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_CAPTURE_ERROR = 4,      /**< Camera error occurred */
} TypesCubeComputerControlProgram8_StarCaptureStatus;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_StarDetectStatus
*/
typedef enum TypesCubeComputerControlProgram8_StarDetectStatusEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_DETECT_STARTUP = 0,    /**< Initialised */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_DETECT_PENDING = 1,    /**< Detection scheduled */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_DETECT_BUSY = 2,       /**< Detection in progress */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_DETECT_ABORT = 3,      /**< Detection stopped because process took too long */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_DETECT_DONE = 4,       /**< Detection completed */
} TypesCubeComputerControlProgram8_StarDetectStatus;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_StarIdStatus
*/
typedef enum TypesCubeComputerControlProgram8_StarIdStatusEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_ID_STARTUP = 0,       /**< Initialised */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_ID_PENDING = 1,       /**< Identification scheduled */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_ID_BUSY = 2,          /**< Identification in progress */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_ID_ABORT = 3,         /**< Identification stopped because process took too long */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_ID_OUT_OF_MEM = 4,    /**< Identification stopped because there is not enough memory for match tables */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_ID_TOO_FEW = 5,       /**< Identification was not attempted because there are not enough detected stars */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_ID_TRACK_ERR = 6,     /**< Identification failed because previously tracked stars could not be located */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STAR_ID_DONE = 7,          /**< Identification completed */
} TypesCubeComputerControlProgram8_StarIdStatus;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_AurigaLibStateVal
*/
typedef enum TypesCubeComputerControlProgram8_AurigaLibStateValEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__INITIALIZATION = 0,    /**< Initialization */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__STANDBY = 1,           /**< Standby Mode */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__SELFTEST = 2,          /**< Self-test Mode */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PHOTO_MODE = 3,        /**< Photo Mode */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__TRACKING = 4,          /**< Tracking */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ARM_MODE = 5,          /**< Angular Rate Mode */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__AAM_MODE = 6,          /**< Attitude Acquisition Mode */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__ATM_MODE = 7,          /**< Attitude Tracking Mode */
} TypesCubeComputerControlProgram8_AurigaLibStateVal;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_OhStateVal
*/
typedef enum TypesCubeComputerControlProgram8_OhStateValEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OH_STATE_OFF = 0,            /**< Optical head switched off */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OH_STATE_WAIT_ON = 1,        /**< Wait On */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OH_STATE_INIT_TEMPO = 2,     /**< Init Tempo */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OH_STATE_CHECK = 3,          /**< Check */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OH_STATE_CONFIG = 4,         /**< Config */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OH_STATE_STANDBY = 5,        /**< Standby */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OH_STATE_ACQ_FF = 6,         /**< Acquire FF */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OH_STATE_ACQ_HW = 7,         /**< Acquire HW */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OH_STATE_FIRST_TRACK = 8,    /**< First Track */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__OH_STATE_TRACKING = 9,       /**< Tracking */
} TypesCubeComputerControlProgram8_OhStateVal;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_MagSensingElementSelect
*/
typedef enum TypesCubeComputerControlProgram8_MagSensingElementSelectEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__MAG_PRIMARY = 0,      /**< Use the primary magnetometer sensing element on the CubeMag */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__MAG_REDUNDANT = 1,    /**< Use the redundant magnetometer sensing element on the CubeMag */
} TypesCubeComputerControlProgram8_MagSensingElementSelect;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_GyroSelect
*/
typedef enum TypesCubeComputerControlProgram8_GyroSelectEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__GYRO_PRIMARY = 0,      /**< Internal Gyro0 (primary IMU) */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__GYRO_REDUNDANT = 1,    /**< Internal Gyro1 (redundant IMU) */
} TypesCubeComputerControlProgram8_GyroSelect;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_FtpOpCode
*/
typedef enum TypesCubeComputerControlProgram8_FtpOpCodeEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FTP_NONE = 0,       /**< No operation */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FTP_CANCEL = 1,     /**< Cancel the Current Transfer */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FTP_UPLOAD = 2,     /**< Upload a File */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FTP_UPGRADE = 3,    /**< Perform Upgrade with file */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FTP_ERASE = 4,      /**< Erase the file */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FTP_INFO = 5,       /**< Retrieve file information and cache it without other operations */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FTP_FORMAT = 6,     /**< Format the filesystem. Effectively erase all files. */
} TypesCubeComputerControlProgram8_FtpOpCode;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_FtpFiles
*/
typedef enum TypesCubeComputerControlProgram8_FtpFilesEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__FILE_INVALID = 0,                        /**< Invalid File */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__BASEBL_CC_BIN = 1,                       /**< Base Bootloader for CubeComputer Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__BASEBL_R5SB_BIN = 2,                     /**< Base Bootloader for R5 nodes - single bank Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__BASEBL_52BIN = 3,                        /**< Base Bootloader for 52 nodes Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_WHEEL_BIN = 4,                      /**< CubeWheel Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_STAR_BIN = 5,                       /**< CubeStar Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_SENSE_BIN = 6,                      /**< CubeSense Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_MAG_DEPLOY_BIN = 7,                 /**< CubeMag Deploy Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_MAG_COMPACT_BIN = 8,                /**< CubeMag Deploy Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_AURIGA_BIN = 9,                     /**< CubeAuriga Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_IR_BIN = 10,                        /**< CubeIR Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_SLT_BIN = 11,                  /**< CubeNode-SLT Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_PST3S_BIN = 12,                /**< CubeNode-PST3S Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_NSSRWL_BIN = 13,               /**< CubeNode-NSSRWL Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_WHEEL_CFG_0 = 14,                   /**< CubeWheel-0 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_WHEEL_CFG_1 = 15,                   /**< CubeWheel-1 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_WHEEL_CFG_2 = 16,                   /**< CubeWheel-2 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_WHEEL_CFG_3 = 17,                   /**< CubeWheel-3 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_WHEEL_CFG_4 = 18,                   /**< CubeWheel-4 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_STAR_CFG_0 = 19,                    /**< CubeStar-0 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_STAR_CFG_1 = 20,                    /**< CubeStar-1 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_STAR_CFG_2 = 21,                    /**< CubeStar-2 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_STAR_CFG_3 = 22,                    /**< CubeStar-3 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_SENSE_CFG_0 = 23,                   /**< CubeSense-0 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_SENSE_CFG_1 = 24,                   /**< CubeSense-1 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_SENSE_CFG_2 = 25,                   /**< CubeSense-2 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_SENSE_CFG_3 = 26,                   /**< CubeSense-3 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_MAG_DEPLOY_CFG_0 = 27,              /**< CubeMag-0 Deploy Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_MAG_DEPLOY_CFG_1 = 28,              /**< CubeMag-1 Deploy Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_MAG_COMPACT_CFG_0 = 29,             /**< CubeMag-0 Compact Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_MAG_COMPACT_CFG_1 = 30,             /**< CubeMag-1 Compact Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_AURIGA_CFG_0 = 31,                  /**< CubeAuriga-0 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_AURIGA_CFG_1 = 32,                  /**< CubeAuriga-1 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_IR_CFG_0 = 33,                      /**< CubeIr-0 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_IR_CFG_1 = 34,                      /**< CubeIr-1 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_SLT_CFG_0 = 35,                /**< CubeNode-SLT-0 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_PST3S_CFG_0 = 36,              /**< CubeNode-PST3S-0 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_PST3S_CFG_1 = 37,              /**< CubeNode-PST3S-1 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_NSSRWL_CFG_0 = 38,             /**< CubeNode-NSSRWL-0 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_NSSRWL_CFG_1 = 39,             /**< CubeNode-NSSRWL-1 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_NSSRWL_CFG_2 = 40,             /**< CubeNode-NSSRWL-2 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_NSSRWL_CFG_3 = 41,             /**< CubeNode-NSSRWL-3 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_QUAD_PST3S_BIN = 42,           /**< CubeNode-PST3S Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_QUAD_PST3S_CFG_0 = 43,         /**< CubeNodeQuad-PST3S-0 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_QUAD_NSSRWL_BIN = 44,          /**< CubeNodeQuad-NSSRWL Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_QUAD_NSSRWL_CFG_0 = 45,        /**< CubeNodeQuad-NSSRWL-0 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_QUAD_LITEFUFORS_BIN = 46,      /**< CubeNodeQuad-LITEFUFORS Image Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_QUAD_LITEFUFORS_CFG_0 = 47,    /**< CubeNode-LITEFUFORS-0 Config Binary */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CUBE_NODE_QUAD_LITEFUFORS_CFG_1 = 48,    /**< CubeNode-LITEFUFORS-1 Config Binary */
} TypesCubeComputerControlProgram8_FtpFiles;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_FtpState
*/
typedef enum TypesCubeComputerControlProgram8_FtpStateEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__IDLE = 0,      /**< No File Transfer in Progress */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__INIT = 1,      /**< Initializing File Operation */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__BUSY = 2,      /**< File Transfer is in Progress */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__LOCKED = 3,    /**< File Transfer service is locked */
} TypesCubeComputerControlProgram8_FtpState;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_FtpUpgradeState
*/
typedef enum TypesCubeComputerControlProgram8_FtpUpgradeStateEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__UPGRADE_IDLE = 0,        /**< No Upgrade in Progress */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__UPGRADE_INIT = 1,        /**< Initializing upgrade operation - first state immediately following transfer setup */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__UPGRADE_TRANS = 2,       /**< Upgrade transitioning from image binary to config binary uupgrade */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__UPGRADE_INIT_BIN = 3,    /**< Initializing image binary upgrade */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__UPGRADE_INIT_CFG = 4,    /**< Initializing config binary upgrade */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__UPGRADE_BUSY_BIN = 5,    /**< Image binary upgrade in progress */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__UPGRADE_BUSY_CFG = 6,    /**< Config binary upgrade in progress */
} TypesCubeComputerControlProgram8_FtpUpgradeState;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_FtpBackend
*/
typedef enum TypesCubeComputerControlProgram8_FtpBackendEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__BACKEND_FRAM = 0,    /**< FRAM Storage Medium */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__BACKEND_NODE = 1,    /**< Node connected on internal bus */
} TypesCubeComputerControlProgram8_FtpBackend;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_FtpFileType
*/
typedef enum TypesCubeComputerControlProgram8_FtpFileTypeEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__BIN = 0,        /**< Binary image file */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__CFG = 1,        /**< Binary config file */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__LOG = 2,        /**< Log file */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PHOTO = 3,      /**< Bitmap photo */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__GENERAL = 4,    /**< General/internal-use */
} TypesCubeComputerControlProgram8_FtpFileType;

/**
 * @brief Enumeration for TypesCubeComputerControlProgram8_NodePort
*/
typedef enum TypesCubeComputerControlProgram8_NodePortEnum {
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_NONE = 0,         /**< No port. Use the value if the Node Port is not relevent */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_WHEEL_1 = 1,      /**< Wheel 1 Port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_WHEEL_2 = 2,      /**< Wheel 2 Port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_WHEEL_3 = 3,      /**< Wheel 3 Port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_WHEEL_4 = 4,      /**< Wheel 4 Port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_SENSOR_1 = 5,     /**< Sensor 1 Port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_SENSOR_2 = 6,     /**< Sensor 2 Port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_SENSOR_3 = 7,     /**< Sensor 3 Port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_SENSOR_4 = 8,     /**< Sensor 4 Port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_SENSOR_5 = 9,     /**< Sensor 5 Port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_SENSOR_6 = 10,    /**< Sensor 6 Port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_SENSOR_7 = 11,    /**< Sensor 7 Port */
    TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8__PORT_SENSOR_8 = 12,    /**< Sensor 8 Port */
} TypesCubeComputerControlProgram8_NodePort;

/**
 * @brief Default mode configuration message structure
 * @details Default mode configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigDefaultModesStruct {
    TypesCubeComputerControlProgram8_AdcsRunModeSelect runModeDefault;    /**< Default ADCS run mode  */
    TypesCubeComputerControlProgram8_AdcsOpStateSelect opStateDefault;    /**< Default ADCS operational state  */
    TypesCubeComputerControlProgram8_ConModeSelect conModeSafe;           /**< Default control mode in OpStateSafe  */
    TypesCubeComputerControlProgram8_ConModeSelect conModeAuto;           /**< Default control mode in OpStateAuto  */
} TypesCubeComputerControlProgram8_ConfigDefaultModes;

/**
 * @brief Mounting configuration message structure
 * @details Mounting configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigMountStruct {
    TypesCubeComputerControlProgram8_AxisSelect mountStackX;          /**< StackX mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountStackY;          /**< StackY mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountStackZ;          /**< StackZ mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountMtq0;            /**< MTQ0 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountMtq1;            /**< MTQ1 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountMtq2;            /**< MTQ2 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountRwl0;            /**< Wheel0 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountRwl1;            /**< Wheel1 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountRwl2;            /**< Wheel2 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountRwl3;            /**< Wheel3 mounting  */
    F64 mountRwlPyrAlpha;                                             /**< Pyramid RWL mounting alpha angle  (measurment unit is [deg]) */
    F64 mountRwlPyrBeta;                                              /**< Pyramid RWL mounting beta angle  (measurment unit is [deg]) */
    F64 mountRwlPyrGamma;                                             /**< Pyramid RWL mounting gamma angle  (measurment unit is [deg]) */
    TypesCubeComputerControlProgram8_AxisSelect mountCss0;            /**< CSS0 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountCss1;            /**< CSS1 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountCss2;            /**< CSS2 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountCss3;            /**< CSS3 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountCss4;            /**< CSS4 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountCss5;            /**< CSS5 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountCss6;            /**< CSS6 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountCss7;            /**< CSS7 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountCss8;            /**< CSS8 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountCss9;            /**< CSS9 mounting  */
    F64 mountFss0Alpha;                                               /**< FSS0 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountFss0Beta;                                                /**< FSS0 mounting beta angle  (measurment unit is [deg]) */
    F64 mountFss0Gamma;                                               /**< FSS0 mounting gamma angle  (measurment unit is [deg]) */
    F64 mountFss1Alpha;                                               /**< FSS1 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountFss1Beta;                                                /**< FSS1 mounting beta angle  (measurment unit is [deg]) */
    F64 mountFss1Gamma;                                               /**< FSS1 mounting gamma angle  (measurment unit is [deg]) */
    F64 mountFss2Alpha;                                               /**< FSS2 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountFss2Beta;                                                /**< FSS2 mounting beta angle  (measurment unit is [deg]) */
    F64 mountFss2Gamma;                                               /**< FSS2 mounting gamma angle  (measurment unit is [deg]) */
    F64 mountFss3Alpha;                                               /**< FSS3 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountFss3Beta;                                                /**< FSS3 mounting beta angle  (measurment unit is [deg]) */
    F64 mountFss3Gamma;                                               /**< FSS3 mounting gamma angle  (measurment unit is [deg]) */
    F64 mountHss0Alpha;                                               /**< HSS0 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountHss0Beta;                                                /**< HSS0 mounting beta angle  (measurment unit is [deg]) */
    F64 mountHss0Gamma;                                               /**< HSS0 mounting gamma angle  (measurment unit is [deg]) */
    F64 mountHss1Alpha;                                               /**< HSS1 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountHss1Beta;                                                /**< HSS1 mounting beta angle  (measurment unit is [deg]) */
    F64 mountHss1Gamma;                                               /**< HSS1 mounting gamma angle  (measurment unit is [deg]) */
    F64 mountMag0Alpha;                                               /**< MAG0 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountMag0Beta;                                                /**< MAG0 mounting beta angle  (measurment unit is [deg]) */
    F64 mountMag0Gamma;                                               /**< MAG0 mounting gamma angle  (measurment unit is [deg]) */
    F64 mountMag1Alpha;                                               /**< MAG1 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountMag1Beta;                                                /**< MAG1 mounting beta angle  (measurment unit is [deg]) */
    F64 mountMag1Gamma;                                               /**< MAG1 mounting gamma angle  (measurment unit is [deg]) */
    F64 mountStr0Alpha;                                               /**< STR0 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountStr0Beta;                                                /**< STR0 mounting beta angle  (measurment unit is [deg]) */
    F64 mountStr0Gamma;                                               /**< STR0 mounting gamma angle  (measurment unit is [deg]) */
    F64 mountStr1Alpha;                                               /**< STR1 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountStr1Beta;                                                /**< STR1 mounting beta angle  (measurment unit is [deg]) */
    F64 mountStr1Gamma;                                               /**< STR1 mounting gamma angle  (measurment unit is [deg]) */
    F64 mountExtSensor0Alpha;                                         /**< ExtSensor0 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountExtSensor0Beta;                                          /**< ExtSensor0 mounting beta angle  (measurment unit is [deg]) */
    F64 mountExtSensor0Gamma;                                         /**< ExtSensor0 mounting gamma angle  (measurment unit is [deg]) */
    F64 mountExtSensor1Alpha;                                         /**< ExtSensor1 mounting alpha angle  (measurment unit is [deg]) */
    F64 mountExtSensor1Beta;                                          /**< ExtSensor1 mounting beta angle  (measurment unit is [deg]) */
    F64 mountExtSensor1Gamma;                                         /**< ExtSensor1 mounting gamma angle  (measurment unit is [deg]) */
    TypesCubeComputerControlProgram8_AxisSelect mountExtGyr0Axis1;    /**< ExtGyro0 axis1 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountExtGyr0Axis2;    /**< ExtGyro0 axis2 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountExtGyr0Axis3;    /**< ExtGyro0 axis3 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountExtGyr1Axis1;    /**< ExtGyro1 axis1 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountExtGyr1Axis2;    /**< ExtGyro1 axis2 mounting  */
    TypesCubeComputerControlProgram8_AxisSelect mountExtGyr1Axis3;    /**< ExtGyro1 axis3 mounting  */
} TypesCubeComputerControlProgram8_ConfigMount;

/**
 * @brief Mag0 magnetometer in-orbit calibration configuration message structure
 * @details Mag0 magnetometer in-orbit calibration configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigMag0OrbitCalStruct {
    F64 offset1;         /**< Magnetometer channel 1 offset  */
    F64 offset2;         /**< Magnetometer channel 2 offset  */
    F64 offset3;         /**< Magnetometer channel 3 offset  */
    F64 sensMatrix11;    /**< Magnetometer sensitivity matrix S11  */
    F64 sensMatrix22;    /**< Magnetometer sensitivity matrix S22  */
    F64 sensMatrix33;    /**< Magnetometer sensitivity matrix S33  */
    F64 sensMatrix12;    /**< Magnetometer sensitivity matrix S12  */
    F64 sensMatrix13;    /**< Magnetometer sensitivity matrix S13  */
    F64 sensMatrix21;    /**< Magnetometer sensitivity matrix S21  */
    F64 sensMatrix23;    /**< Magnetometer sensitivity matrix S23  */
    F64 sensMatrix31;    /**< Magnetometer sensitivity matrix S31  */
    F64 sensMatrix32;    /**< Magnetometer sensitivity matrix S32  */
} TypesCubeComputerControlProgram8_ConfigMag0OrbitCal;

/**
 * @brief Mag1 magnetometer in-orbit calibration configuration message structure
 * @details Mag1 magnetometer in-orbit calibration configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigMag1OrbitCalStruct {
    F64 offset1;         /**< Magnetometer channel 1 offset  */
    F64 offset2;         /**< Magnetometer channel 2 offset  */
    F64 offset3;         /**< Magnetometer channel 3 offset  */
    F64 sensMatrix11;    /**< Magnetometer sensitivity matrix S11  */
    F64 sensMatrix22;    /**< Magnetometer sensitivity matrix S22  */
    F64 sensMatrix33;    /**< Magnetometer sensitivity matrix S33  */
    F64 sensMatrix12;    /**< Magnetometer sensitivity matrix S12  */
    F64 sensMatrix13;    /**< Magnetometer sensitivity matrix S13  */
    F64 sensMatrix21;    /**< Magnetometer sensitivity matrix S21  */
    F64 sensMatrix23;    /**< Magnetometer sensitivity matrix S23  */
    F64 sensMatrix31;    /**< Magnetometer sensitivity matrix S31  */
    F64 sensMatrix32;    /**< Magnetometer sensitivity matrix S32  */
} TypesCubeComputerControlProgram8_ConfigMag1OrbitCal;

/**
 * @brief ADCS controller configuration message structure
 * @details ADCS controller configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigAdcsControllerStruct {
    TypesCubeComputerControlProgram8_ConModeSelect conModeDefault;    /**< Default control mode  */
    F32 kd;                                                           /**< Detumbling damping gain (Kd)  (valid range is between 0  and 10000 ) */
    F32 kdsun;                                                        /**< Sun-spin control gain (KDsun)  (valid range is between -1000  and 1000 ) */
    F32 kdecl;                                                        /**< Sun-spin control gain (KDecl)  (valid range is between -1000  and 1000 ) */
    F32 ks;                                                           /**< Detumbling spin gain (Ks)  (valid range is between 0  and 10000 ) */
    F32 kdf;                                                          /**< Fast B-dot detumbling gain (Kdf)  (valid range is between 0  and 100 ) */
    F32 kn;                                                           /**< Y-momentum nutation damping gain (Kn)  (valid range is between 0  and 10000 ) */
    F32 kq;                                                           /**< Y-momentum nutation damping quaternion gain (Kq)  (valid range is between 0  and 10000 ) */
    F32 kqx;                                                          /**< X-axis GG nutation damping quaternion gain (Kqx)  (valid range is between 0  and 10000 ) */
    F32 kqy;                                                          /**< Y-axis GG nutation damping quaternion gain (Kqy)  (valid range is between 0  and 10000 ) */
    F32 kqz;                                                          /**< Z-axis GG nutation damping quaternion gain (Kqz)  (valid range is between 0  and 10000 ) */
    F32 kh;                                                           /**< Wheel momentum dumping magnetic control gain (Kh)  (valid range is between 0  and 10000 ) */
    F32 kp1;                                                          /**< Y-momentum proportional gain (Kp1)  (valid range is between 0  and 100 ) */
    F32 kd1;                                                          /**< Y-momentum derivative gain (Kd1)  (valid range is between 0  and 100 ) */
    F32 kp2;                                                          /**< RWheel proportional gain (Kp2)  (valid range is between 0  and 100 ) */
    F32 kd2;                                                          /**< RWheel derivative gain (Kd2)  (valid range is between 0  and 100 ) */
    F32 kp3;                                                          /**< Tracking proportional gain (Kp3)  (valid range is between 0  and 100 ) */
    F32 kd3;                                                          /**< Tracking derivative gain (Kd3)  (valid range is between 0  and 100 ) */
    F32 ki3;                                                          /**< Tracking integral gain (Ki3)  (valid range is between 0  and 100 ) */
    F32 wy_ref;                                                       /**< Reference spin rate (wy-ref)  (measurment unit is [degps]. valid range is between -5 degps and 5 degps) */
    F32 h_ref;                                                        /**< Reference wheel momentum (H-ref). Must always be smaller than 0  (measurment unit is [Nms]. valid range is between -10 Nms and 0 Nms) */
    F32 hy_bias;                                                      /**< Y-wheel bias momentum during XYZ-control (Hy-bias)  (measurment unit is [Nms]. valid range is between -10 Nms and 10 Nms) */
    F32 wSunYawRef;                                                   /**< Reference spin rate for ConSunYawSpin RW control  (measurment unit is [degps]. valid range is between -20 degps and 20 degps) */
    F32 sunKeepoutAng;                                                /**< Sun keep-out angle  (measurment unit is [deg]. valid range is between 0 deg and 90 deg) */
    F32 rollLimit;                                                    /**< Limit roll angle in ConRollSun and ConRollTarget  (measurment unit is [deg]. valid range is between 0 deg and 180 deg) */
    Boolean yawCompensate;                                            /**< Perform yaw compensation for earth rotation in 3-axis RPY control  */
    Boolean sunTrackEclEn;                                            /**< Enable sun tracking during eclipse when using ConSunTrack  */
    Boolean sunAvoidEn;                                               /**< Enable sun avoidance  */
} TypesCubeComputerControlProgram8_ConfigAdcsController;

/**
 * @brief ADCS estimator configuration message structure
 * @details ADCS estimator configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigAdcsEstimatorStruct {
    TypesCubeComputerControlProgram8_EstModeSelect estModeMainDefault;      /**< Default main estimator mode  */
    TypesCubeComputerControlProgram8_EstModeSelect estModeBackupDefault;    /**< Default backup estimator mode  */
    F32 magR;                                                               /**< Magnetometer measurement noise  (valid range is between 0  and 1 ) */
    F32 cssR;                                                               /**< Coarse sun sensor measurement noise  (valid range is between 0  and 10 ) */
    F32 fssR;                                                               /**< Fine sun sensor measurement noise  (valid range is between 0  and 1 ) */
    F32 hssR;                                                               /**< Horizon sensor measurement noise  (valid range is between 0  and 1 ) */
    F32 strR;                                                               /**< Star tracker measurement noise  (valid range is between 0  and 0.1 ) */
    F32 rkfQ;                                                               /**< Magnetometer RKF system noise  (valid range is between 0  and 0.01 ) */
    F32 ekfQ;                                                               /**< EKF system noise  (valid range is between 0  and 0.01 ) */
    F32 nutDeps;                                                            /**< Polar nutation Epsilon correction  (measurment unit is [rad]. valid range is between -0.1 rad and 0.1 rad) */
    F32 nutDpsi;                                                            /**< Polar nutation Psi correction  (measurment unit is [rad]. valid range is between -0.1 rad and 0.1 rad) */
    Boolean ekfUseFss;                                                      /**< Use fine sun sensor measurements in EKF  */
    Boolean ekfUseCss;                                                      /**< Use coarse sun sensor measurements in EKF  */
    Boolean ekfUseHss;                                                      /**< Use horizon sensor measurements in EKF  */
    Boolean ekfUseStr;                                                      /**< Use star tracker measurements in EKF  */
    TypesCubeComputerControlProgram8_VecSelect tVec1;                       /**< Vector 1 selection for Triad  */
    TypesCubeComputerControlProgram8_VecSelect tVec2;                       /**< Vector 2 selection for Triad  */
} TypesCubeComputerControlProgram8_ConfigAdcsEstimator;

/**
 * @brief ADCS satellite configuration message structure
 * @details ADCS satellite configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigAdcsSatelliteStruct {
    F32 ixx;                 /**< Moment of inertia Ixx  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 100 kg.m^2) */
    F32 iyy;                 /**< Moment of inertia Iyy  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 100 kg.m^2) */
    F32 izz;                 /**< Moment of inertia Izz  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 100 kg.m^2) */
    F32 ixy;                 /**< Product of inertia Ixy  (measurment unit is [kg.m^2]. valid range is between -10 kg.m^2 and 10 kg.m^2) */
    F32 ixz;                 /**< Product of inertia Ixz  (measurment unit is [kg.m^2]. valid range is between -10 kg.m^2 and 10 kg.m^2) */
    F32 iyz;                 /**< Product of inertia Iyz  (measurment unit is [kg.m^2]. valid range is between -10 kg.m^2 and 10 kg.m^2) */
    F64 sunPointBodyVecX;    /**< Sun-pointing body vector X component  */
    F64 sunPointBodyVecY;    /**< Sun-pointing body vector Y component  */
    F64 sunPointBodyVecZ;    /**< Sun-pointing body vector Z component  */
    F64 tgtTrackBodyVecX;    /**< Target-tracking body vector X component  */
    F64 tgtTrackBodyVecY;    /**< Target-tracking body vector Y component  */
    F64 tgtTrackBodyVecZ;    /**< Target-tracking body vector Z component  */
    F64 satTrackBodyVecX;    /**< Satellite-tracking body vector X component  */
    F64 satTrackBodyVecY;    /**< Satellite-tracking body vector Y component  */
    F64 satTrackBodyVecZ;    /**< Satellite-tracking body vector Z component  */
} TypesCubeComputerControlProgram8_ConfigAdcsSatellite;

/**
 * @brief Satellite orbit parameter configuration message structure
 * @details Satellite orbit parameter configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigOrbitSatParamsStruct {
    F64 orbitEpoch;    /**< Orbit epoch  (measurment unit is [yyddd.ssssssss]. valid range is between 0 yyddd.ssssssss and 100000 yyddd.ssssssss) */
    F64 orbitIncl;     /**< Orbit inclination  (measurment unit is [deg]. valid range is between 0 deg and 180 deg) */
    F64 orbitRaan;     /**< Orbit RAAN  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 orbitEccen;    /**< Orbit eccentricity  (valid range is between 0  and 1 ) */
    F64 orbitAP;       /**< Orbit argument of perigee  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 orbitMA;       /**< Orbit mean anomaly  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 orbitMM;       /**< Orbit mean motion  (measurment unit is [orbits/day]. valid range is between 0 orbits/day and 20 orbits/day) */
    F64 orbitBstar;    /**< Orbit B-star drag term  (valid range is between 0  and 1 ) */
} TypesCubeComputerControlProgram8_ConfigOrbitSatParams;

/**
 * @brief Target satellite orbit parameter configuration message structure
 * @details Satellite orbit parameter configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigOrbitTargetParamsStruct {
    F64 orbitEpoch;    /**< Orbit epoch  (measurment unit is [yyddd.ssssssss]. valid range is between 0 yyddd.ssssssss and 100000 yyddd.ssssssss) */
    F64 orbitIncl;     /**< Orbit inclination  (measurment unit is [deg]. valid range is between 0 deg and 180 deg) */
    F64 orbitRaan;     /**< Orbit RAAN  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 orbitEccen;    /**< Orbit eccentricity  (valid range is between 0  and 1 ) */
    F64 orbitAP;       /**< Orbit argument of perigee  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 orbitMA;       /**< Orbit mean anomaly  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 orbitMM;       /**< Orbit mean motion  (measurment unit is [orbits/day]. valid range is between 0 orbits/day and 20 orbits/day) */
    F64 orbitBstar;    /**< Orbit B-star drag term  (valid range is between 0  and 1 ) */
} TypesCubeComputerControlProgram8_ConfigOrbitTargetParams;

/**
 * @brief Node selection configuration message structure
 * @details Node selection configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigNodeSelectionStruct {
    U8 selectRwl;     /**< RWL selection flags  */
    U8 selectMag;     /**< MAG selection flags  */
    U8 selectFss;     /**< FSS selection flags  */
    U8 selectHss;     /**< HSS selection flags  */
    U8 selectGyro;    /**< GYR selection flags  */
    U8 selectStr;     /**< STR selection flags  */
    U8 selectGnss;    /**< GNSS selection flags  */
    U8 selectExt;     /**< External sensor selection flags  */
} TypesCubeComputerControlProgram8_ConfigNodeSelection;

/**
 * @brief Wheel configuration message structure
 * @details Wheel configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigActuatorRwlStruct {
    F32 rwl0Iw;                                              /**< RWL0 inertia  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 1 kg.m^2) */
    F32 rwl0Hmax;                                            /**< RWL0 maximum momentum  (measurment unit is [N.m.s]. valid range is between 0 N.m.s and 10 N.m.s) */
    F32 rwl0Nmax;                                            /**< RWL0 maximum torque  (measurment unit is [N.m]. valid range is between 0 N.m and 1 N.m) */
    F32 rwl1Iw;                                              /**< RWL1 inertia  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 1 kg.m^2) */
    F32 rwl1Hmax;                                            /**< RWL1 maximum momentum  (measurment unit is [N.m.s]. valid range is between 0 N.m.s and 10 N.m.s) */
    F32 rwl1Nmax;                                            /**< RWL1 maximum torque  (measurment unit is [N.m]. valid range is between 0 N.m and 1 N.m) */
    F32 rwl2Iw;                                              /**< RWL2 inertia  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 1 kg.m^2) */
    F32 rwl2Hmax;                                            /**< RWL2 maximum momentum  (measurment unit is [N.m.s]. valid range is between 0 N.m.s and 10 N.m.s) */
    F32 rwl2Nmax;                                            /**< RWL2 maximum torque  (measurment unit is [N.m]. valid range is between 0 N.m and 1 N.m) */
    F32 rwl3Iw;                                              /**< RWL3 inertia  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 1 kg.m^2) */
    F32 rwl3Hmax;                                            /**< RWL3 maximum momentum  (measurment unit is [N.m.s]. valid range is between 0 N.m.s and 10 N.m.s) */
    F32 rwl3Nmax;                                            /**< RWL3 maximum torque  (measurment unit is [N.m]. valid range is between 0 N.m and 1 N.m) */
    F32 nDel;                                                /**< Wheel ramp torque  (measurment unit is [N.m]. valid range is between 0 N.m and 1 N.m) */
    TypesCubeComputerControlProgram8_RwlScheme rwlScheme;    /**< Wheel scheme  */
    TypesCubeComputerControlProgram8_RwlFailId rwlFailId;    /**< Failed wheel ID  */
    F32 pyrHnom;                                             /**< Pyramid nominal momentum  (measurment unit is [N.m.s]. valid range is between 0 N.m.s and 10 N.m.s) */
    F32 pyrTiltAngle;                                        /**< Pyramid tilt angle  (measurment unit is [deg]. valid range is between 0 deg and 90 deg) */
} TypesCubeComputerControlProgram8_ConfigActuatorRwl;

/**
 * @brief Magnetorquer configuration message structure
 * @details Magnetorquer configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigActuatorMtqStruct {
    F32 mtq0Mmax;     /**< MTQ0 maximum dipole moment  (measurment unit is [A.m^2]. valid range is between 0 A.m^2 and 400 A.m^2) */
    F32 mtq1Mmax;     /**< MTQ1 maximum dipole moment  (measurment unit is [A.m^2]. valid range is between 0 A.m^2 and 400 A.m^2) */
    F32 mtq2Mmax;     /**< MTQ2 maximum dipole moment  (measurment unit is [A.m^2]. valid range is between 0 A.m^2 and 400 A.m^2) */
    U16 onTimeMax;    /**< Maximum magnetorquer on-time  (measurment unit is [ms]) */
    U16 onTimeMin;    /**< Minimum magnetorquer on-time  (measurment unit is [ms]) */
    F32 mtqFfac;      /**< LPF factor for magnetorquer commands. Set to zero for no filtering  (valid range is between 0  and 1 ) */
} TypesCubeComputerControlProgram8_ConfigActuatorMtq;

/**
 * @brief Mag sensing element configuration message structure
 * @details Mag sensing element (primary/redundant) configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigMagSensingElementStruct {
    TypesCubeComputerControlProgram8_MagSensingElementSelect mag0SensingElement;    /**< MAG0 sensing element (primary/redundant)  */
    TypesCubeComputerControlProgram8_MagSensingElementSelect mag1SensingElement;    /**< MAG1 sensing element (primary/redundant)  */
} TypesCubeComputerControlProgram8_ConfigMagSensingElement;

/**
 * @brief Augmented SGP4 configuration message structure
 * @details Augmented SGP4 configuration
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConfigAsgp4Struct {
    U16 batchSize;             /**< Number of GNSS measurements before computing updates TLEs  */
    U32 maxTimeBetween;        /**< Maximum time between GNSS measurements before resetting filters  (measurment unit is [s]. valid range is between 0 s and 100000 s) */
    U16 maxPosErr;             /**< Maximum position error for asgp4 to continue working  (measurment unit is [km]. valid range is between 0 km and 1000 km) */
    F32 timeGain;              /**< Time offset compensation gain  (valid range is between 0  and 10 ) */
    Boolean updateRaanIncl;    /**< Update SGP4 RAAN and Inclination angles from GNSS  */
    Boolean updateEccen;       /**< Update SGP4 Eccentricity from GNSS  */
    Boolean updateApMa;        /**< Update SGP4 Arg. Perigee and Mean Anomaly from GNSS  */
    Boolean updateTime;        /**< Update SGP4 Epoch from GNSS  */
} TypesCubeComputerControlProgram8_ConfigAsgp4;

/**
 * @brief Raw CSS sensor telemetry message structure
 * @details Raw CSS sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorRawCssStruct {
    U32 timeSeconds;       /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;            /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    U8 css0Raw;            /**< CSS0 raw measurement  */
    U8 css1Raw;            /**< CSS1 raw measurement  */
    U8 css2Raw;            /**< CSS2 raw measurement  */
    U8 css3Raw;            /**< CSS3 raw measurement  */
    U8 css4Raw;            /**< CSS4 raw measurement  */
    U8 css5Raw;            /**< CSS5 raw measurement  */
    U8 css6Raw;            /**< CSS6 raw measurement  */
    U8 css7Raw;            /**< CSS7 raw measurement  */
    U8 css8Raw;            /**< CSS8 raw measurement  */
    U8 css9Raw;            /**< CSS9 raw measurement  */
    Boolean cssIsValid;    /**< CSS valid flag  */
} TypesCubeComputerControlProgram8_TlmSensorRawCss;

/**
 * @brief Raw MAG sensor telemetry message structure
 * @details Raw MAG sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorRawMagStruct {
    U32 timeSeconds;        /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;             /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 mag0RawVecX;        /**< MAG0 raw vector X component  (measurment unit is [uT]) */
    F64 mag0RawVecY;        /**< MAG0 raw vector Y component  (measurment unit is [uT]) */
    F64 mag0RawVecZ;        /**< MAG0 raw vector Z component  (measurment unit is [uT]) */
    F64 mag1RawVecX;        /**< MAG1 raw vector X component  (measurment unit is [uT]) */
    F64 mag1RawVecY;        /**< MAG1 raw vector Y component  (measurment unit is [uT]) */
    F64 mag1RawVecZ;        /**< MAG1 raw vector Z component  (measurment unit is [uT]) */
    Boolean mag0IsValid;    /**< MAG0 valid flag  */
    Boolean mag1IsValid;    /**< MAG1 valid flag  */
} TypesCubeComputerControlProgram8_TlmSensorRawMag;

/**
 * @brief Raw GYR sensor telemetry message structure
 * @details Raw GYRO sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorRawGyroStruct {
    U32 timeSeconds;         /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;              /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F32 gyro0RawRateX;       /**< GYR0 raw rate X component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro0RawRateY;       /**< GYR0 raw rate Y component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro0RawRateZ;       /**< GYR0 raw rate Z component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro1RawRateX;       /**< GYR1 raw rate X component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro1RawRateY;       /**< GYR1 raw rate Y component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro1RawRateZ;       /**< GYR1 raw rate Z component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    Boolean gyro0IsValid;    /**< GYR0 valid flag  */
    Boolean gyro1IsValid;    /**< GYR1 valid flag  */
} TypesCubeComputerControlProgram8_TlmSensorRawGyro;

/**
 * @brief Raw CubeSense Earth telemetry message structure
 * @details Raw CubeSense Earth telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmHssCubeSenseEarthRawStruct {
    U32 timeSeconds;                                                           /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                                                                /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 hss0RawElev;                                                           /**< HSS0 raw elevation angle  (measurment unit is [deg]) */
    F64 hss0RawRot;                                                            /**< HSS0 raw rotation angle  (measurment unit is [deg]) */
    TypesCubeComputerControlProgram8_EarthCaptureResult hss0CaptureResult;     /**< HSS0 capture result  */
    TypesCubeComputerControlProgram8_EarthDetectResult hss0DetectionResult;    /**< HSS0 detection result  */
    F64 hss1RawElev;                                                           /**< HSS1 raw elevation angle  (measurment unit is [deg]) */
    F64 hss1RawRot;                                                            /**< HSS1 raw rotation angle  (measurment unit is [deg]) */
    TypesCubeComputerControlProgram8_EarthCaptureResult hss1CaptureResult;     /**< HSS1 capture result  */
    TypesCubeComputerControlProgram8_EarthDetectResult hss1DetectionResult;    /**< HSS1 detection result  */
    Boolean hss0IsValid;                                                       /**< HSS0 valid flag  */
    Boolean hss1IsValid;                                                       /**< HSS1 valid flag  */
} TypesCubeComputerControlProgram8_TlmHssCubeSenseEarthRaw;

/**
 * @brief Raw GNSS sensor telemetry message structure
 * @details Raw GNSS sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmGnssRawStruct {
    U32 rtcTimeSeconds;         /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 rtcTimeNs;              /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    S32 rtcDriftNs;             /**< Drift per second  (measurment unit is [ns]) */
    F32 gnssSatPosEcefX;        /**< Satellite ECEF position vector X component  (measurment unit is [m]) */
    F32 gnssSatPosEcefY;        /**< Satellite ECEF position vector Y component  (measurment unit is [m]) */
    F32 gnssSatPosEcefZ;        /**< Satellite ECEF position vector Z component  (measurment unit is [m]) */
    F32 gnssSatVelEcefX;        /**< Satellite ECEF velocity vector X component  (measurment unit is [m/s]) */
    F32 gnssSatVelEcefY;        /**< Satellite ECEF velocity vector Y component  (measurment unit is [m/s]) */
    F32 gnssSatVelEcefZ;        /**< Satellite ECEF velocity vector Z component  (measurment unit is [m/s]) */
    U32 gnssTimeSeconds;        /**< GNSS-supplied unix time integer seconds  (measurment unit is [s]) */
    U32 gnssTimeNs;             /**< GNSS-supplied unix time nanoseconds  (measurment unit is [ns]) */
    U16 gpsWeek;                /**< GPS week number  */
    U32 tow;                    /**< GNSS Time of Week  (measurment unit is [ms]) */
    S8 utcOffset;               /**< Offset between GNSS time and UTC  (measurment unit is [s]) */
    Boolean gnssValidData;      /**< GNSS data is valid, but may be outdated  */
    Boolean gnssLock;           /**< GNSS has lock, data most recent  */
    Boolean gnssPPSDetected;    /**< GNSS PPS Detected by ADCS HW  */
} TypesCubeComputerControlProgram8_TlmGnssRaw;

/**
 * @brief Raw RWL sensor telemetry message structure
 * @details Raw RWL sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorRawRwlStruct {
    U32 timeSeconds;        /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;             /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F32 rwl0MeasSpeed;      /**< RWL0 measured speed  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl1MeasSpeed;      /**< RWL1 measured speed  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl2MeasSpeed;      /**< RWL2 measured speed  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl3MeasSpeed;      /**< RWL3 measured speed  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    Boolean rwl0IsValid;    /**< RWL0 valid flag  */
    Boolean rwl1IsValid;    /**< RWL1 valid flag  */
    Boolean rwl2IsValid;    /**< RWL2 valid flag  */
    Boolean rwl3IsValid;    /**< RWL3 valid flag  */
} TypesCubeComputerControlProgram8_TlmSensorRawRwl;

/**
 * @brief Raw external sensor telemetry message structure
 * @details Raw external sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmExtSensorRawStruct {
    U32 timeSeconds;              /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                   /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F32 extSensor0Float0;         /**< ExtSensor0 raw float 0  */
    F32 extSensor0Float1;         /**< ExtSensor0 raw float 1  */
    F32 extSensor0Float2;         /**< ExtSensor0 raw float 2  */
    F32 extSensor0Float3;         /**< ExtSensor0 raw float 3  */
    F32 extSensor0Float4;         /**< ExtSensor0 raw float 4  */
    F32 extSensor0Float5;         /**< ExtSensor0 raw float 5  */
    F32 extSensor1Float0;         /**< ExtSensor1 raw float 0  */
    F32 extSensor1Float1;         /**< ExtSensor1 raw float 1  */
    F32 extSensor1Float2;         /**< ExtSensor1 raw float 2  */
    F32 extSensor1Float3;         /**< ExtSensor1 raw float 3  */
    F32 extSensor1Float4;         /**< ExtSensor1 raw float 4  */
    F32 extSensor1Float5;         /**< ExtSensor1 raw float 5  */
    Boolean extSensor0IsValid;    /**< ExtSensor0 valid flag  */
    Boolean extSensor1IsValid;    /**< ExtSensor1 valid flag  */
} TypesCubeComputerControlProgram8_TlmExtSensorRaw;

/**
 * @brief Raw PST3S star tracker telemetry message structure
 * @details Raw PST3S star tracker telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmStrPst3sRawStruct {
    U32 timeSeconds;                                                                                   /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                                                                                        /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    TypesCubeComputerControlProgram8_Pst3sVersion str0Pst3sVersion;                                    /**< STR0 PST3S Version  */
    F32 str0Quat1;                                                                                     /**< PST3S Quaternion 1  (valid range is between -1  and 1 ) */
    F32 str0Quat2;                                                                                     /**< PST3S Quaternion 2  (valid range is between -1  and 1 ) */
    F32 str0Quat3;                                                                                     /**< PST3S Quaternion 3  (valid range is between -1  and 1 ) */
    F32 str0Quat4;                                                                                     /**< PST3S Quaternion 4  (valid range is between -1  and 1 ) */
    F32 str0AngVelX;                                                                                   /**< PST3S Angular Valocity X  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 str0AngVelY;                                                                                   /**< PST3S Angular Valocity Y  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 str0AngVelZ;                                                                                   /**< PST3S Angular Valocity Z  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    TypesCubeComputerControlProgram8_Pst3sRateQuality str0RateQuality;                                 /**< PST3S Rate Quality  */
    U32 str0UnixSeconds;                                                                               /**< PST3S Unix Seconds  (measurment unit is [S]) */
    F32 str0UnixSecondsDecimal;                                                                        /**< PST3S Unix Seconds Decimal  (measurment unit is [S]. valid range is between 0 S and 1 S) */
    S8 str0Temperature;                                                                                /**< PST3S Temperature  (measurment unit is [C]) */
    U8 str0ImageExposure;                                                                              /**< PST3S Image Exposure  */
    U8 str0ImageThreshold;                                                                             /**< PST3S Image Threshold  */
    U8 str0BackGroundValues;                                                                           /**< PST3S BackGround Values  */
    U8 str0InternalProcessCode;                                                                        /**< PST3S Internal Process Code  */
    TypesCubeComputerControlProgram8_Pst3sSelfTestResult str0CmosChipIdResult;                         /**< PST3S CMOS Chip ID Self-test Result  */
    TypesCubeComputerControlProgram8_Pst3sSelfTestResult str0FpgaMRamResult;                           /**< PST3S FPGA MRAM Self-test Result  */
    U8 str0NumberOfExtractedStars;                                                                     /**< PST3S Number of Extracted Stars  */
    TypesCubeComputerControlProgram8_Pst3sOperatingModes str0OperatingMode;                            /**< PST3S Operating Mode  */
    U8 str0ImagingGain;                                                                                /**< PST3S Imaging Gain  */
    U8 str0MinNavigationStars;                                                                         /**< PST3S Minimum Navigation Stars When Quaternion is Valid  */
    TypesCubeComputerControlProgram8_Pst3sDataValid str0DataValid;                                     /**< PST3S Data Valid  */
    TypesCubeComputerControlProgram8_Pst3sExtImageState str0ExtImageState;                             /**< PST3S External Image State  */
    U8 str0IdentifiedStars;                                                                            /**< PST3S Number of Identified Stars  */
    U8 str0DeviceNumber;                                                                               /**< PST3S Device Number  */
    U8 str0SoftwareVersion;                                                                            /**< PST3S Software Version  */
    U8 str0EdacErrorCount;                                                                             /**< PST3S EDAC Error Count  */
    U32 str0ImageFrameNumber;                                                                          /**< PST3S Image Frame Number  */
    TypesCubeComputerControlProgram8_Pst3sDynamicMode str0DynamicMode;                                 /**< PST3S Dynamic Mode  */
    TypesCubeComputerControlProgram8_Pst3sSaaWorkingMode str0SaaMode;                                  /**< PST3S SAA Mode  */
    U8 str0SaaThreshold;                                                                               /**< PST3S SAA Threshold  */
    TypesCubeComputerControlProgram8_Pst3sQuaternionFilteringGetState str0QuaternionFilteringState;    /**< PST3S Quaternion Filtering State  */
    U8 str0FourStarCaptureThreshold;                                                                   /**< PST3S Four Star Capture Threshold  */
    U8 str0TrackingThreshold;                                                                          /**< PST3S Tracking Threshold  */
    Boolean str0EdacSwitch;                                                                            /**< PST3S EDAC Enabled/Disabled  */
    TypesCubeComputerControlProgram8_Pst3sVersion str1Pst3sVersion;                                    /**< STR1 PST3S Version  */
    F32 str1Quat1;                                                                                     /**< PST3S Quaternion 1  (valid range is between -1  and 1 ) */
    F32 str1Quat2;                                                                                     /**< PST3S Quaternion 2  (valid range is between -1  and 1 ) */
    F32 str1Quat3;                                                                                     /**< PST3S Quaternion 3  (valid range is between -1  and 1 ) */
    F32 str1Quat4;                                                                                     /**< PST3S Quaternion 4  (valid range is between -1  and 1 ) */
    F32 str1AngVelX;                                                                                   /**< PST3S Angular Valocity X  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 str1AngVelY;                                                                                   /**< PST3S Angular Valocity Y  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 str1AngVelZ;                                                                                   /**< PST3S Angular Valocity Z  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    TypesCubeComputerControlProgram8_Pst3sRateQuality str1RateQuality;                                 /**< PST3S Rate Quality  */
    U32 str1UnixSeconds;                                                                               /**< PST3S Unix Seconds  (measurment unit is [S]) */
    F32 str1UnixSecondsDecimal;                                                                        /**< PST3S Unix Seconds Decimal  (measurment unit is [S]. valid range is between 0 S and 1 S) */
    S8 str1Temperature;                                                                                /**< PST3S Temperature  (measurment unit is [C]) */
    U8 str1ImageExposure;                                                                              /**< PST3S Image Exposure  */
    U8 str1ImageThreshold;                                                                             /**< PST3S Image Threshold  */
    U8 str1BackGroundValues;                                                                           /**< PST3S BackGround Values  */
    U8 str1InternalProcessCode;                                                                        /**< PST3S Internal Process Code  */
    TypesCubeComputerControlProgram8_Pst3sSelfTestResult str1CmosChipIdResult;                         /**< PST3S CMOS Chip ID Self-test Result  */
    TypesCubeComputerControlProgram8_Pst3sSelfTestResult str1FpgaMRamResult;                           /**< PST3S FPGA MRAM Self-test Result  */
    U8 str1NumberOfExtractedStars;                                                                     /**< PST3S Number of Extracted Stars  */
    TypesCubeComputerControlProgram8_Pst3sOperatingModes str1OperatingMode;                            /**< PST3S Operating Mode  */
    U8 str1ImagingGain;                                                                                /**< PST3S Imaging Gain  */
    U8 str1MinNavigationStars;                                                                         /**< PST3S Minimum Navigation Stars When Quaternion is Valid  */
    TypesCubeComputerControlProgram8_Pst3sDataValid str1DataValid;                                     /**< PST3S Data Valid  */
    TypesCubeComputerControlProgram8_Pst3sExtImageState str1ExtImageState;                             /**< PST3S External Image State  */
    U8 str1IdentifiedStars;                                                                            /**< PST3S Number of Identified Stars  */
    U8 str1DeviceNumber;                                                                               /**< PST3S Device Number  */
    U8 str1SoftwareVersion;                                                                            /**< PST3S Software Version  */
    U8 str1EdacErrorCount;                                                                             /**< PST3S EDAC Error Count  */
    U32 str1ImageFrameNumber;                                                                          /**< PST3S Image Frame Number  */
    TypesCubeComputerControlProgram8_Pst3sDynamicMode str1DynamicMode;                                 /**< PST3S Dynamic Mode  */
    TypesCubeComputerControlProgram8_Pst3sSaaWorkingMode str1SaaMode;                                  /**< PST3S SAA Mode  */
    U8 str1SaaThreshold;                                                                               /**< PST3S SAA Threshold  */
    TypesCubeComputerControlProgram8_Pst3sQuaternionFilteringGetState str1QuaternionFilteringState;    /**< PST3S Quaternion Filtering State  */
    U8 str1FourStarCaptureThreshold;                                                                   /**< PST3S Four Star Capture Threshold  */
    U8 str1TrackingThreshold;                                                                          /**< PST3S Tracking Threshold  */
    Boolean str1EdacSwitch;                                                                            /**< PST3S EDAC Enabled/Disabled  */
} TypesCubeComputerControlProgram8_TlmStrPst3sRaw;

/**
 * @brief Raw CubeSense Sun telemetry message structure
 * @details Raw CubeSense Sun telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmFssCubeSenseSunRawStruct {
    U32 timeSeconds;                                                         /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                                                              /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 fss0Alpha;                                                           /**< FSS0 alpha Angle  (measurment unit is [deg]) */
    F64 fss0Beta;                                                            /**< FSS0 beta Angle  (measurment unit is [deg]) */
    TypesCubeComputerControlProgram8_SunCaptureResult fss0CaptureResult;     /**< FSS0 capture result  */
    TypesCubeComputerControlProgram8_SunDetectResult fss0DetectionResult;    /**< FSS0 detection result  */
    F64 fss1Alpha;                                                           /**< FSS1 alpha Angle  (measurment unit is [deg]) */
    F64 fss1Beta;                                                            /**< FSS1 beta Angle  (measurment unit is [deg]) */
    TypesCubeComputerControlProgram8_SunCaptureResult fss1CaptureResult;     /**< FSS1 capture result  */
    TypesCubeComputerControlProgram8_SunDetectResult fss1DetectionResult;    /**< FSS1 detection result  */
    F64 fss2Alpha;                                                           /**< FSS2 alpha Angle  (measurment unit is [deg]) */
    F64 fss2Beta;                                                            /**< FSS2 beta Angle  (measurment unit is [deg]) */
    TypesCubeComputerControlProgram8_SunCaptureResult fss2CaptureResult;     /**< FSS2 capture result  */
    TypesCubeComputerControlProgram8_SunDetectResult fss2DetectionResult;    /**< FSS2 detection result  */
    F64 fss3Alpha;                                                           /**< FSS3 alpha Angle  (measurment unit is [deg]) */
    F64 fss3Beta;                                                            /**< FSS3 beta Angle  (measurment unit is [deg]) */
    TypesCubeComputerControlProgram8_SunCaptureResult fss3CaptureResult;     /**< FSS3 capture result  */
    TypesCubeComputerControlProgram8_SunDetectResult fss3DetectionResult;    /**< FSS3 detection result  */
    Boolean fss0IsValid;                                                     /**< FSS0 valid flag  */
    Boolean fss1IsValid;                                                     /**< FSS1 valid flag  */
    Boolean fss2IsValid;                                                     /**< FSS2 valid flag  */
    Boolean fss3IsValid;                                                     /**< FSS3 valid flag  */
} TypesCubeComputerControlProgram8_TlmFssCubeSenseSunRaw;

/**
 * @brief Raw CubeStar telemetry message structure
 * @details Raw CubeStar telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmStrCubeStarRawStruct {
    U32 timeSeconds;                                                         /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                                                              /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    TypesCubeComputerControlProgram8_StarCaptureStatus str0CaptureStatus;    /**< Status of image capture operation  */
    TypesCubeComputerControlProgram8_StarDetectStatus str0DetectStatus;      /**< Status of star detection operation  */
    TypesCubeComputerControlProgram8_StarIdStatus str0IdentStatus;           /**< Status of star identification operation  */
    Boolean str0Idle;                                                        /**< CubeStar is idle and can accept new command  */
    Boolean str0Tracking;                                                    /**< CubeStar is in tracking mode  */
    Boolean str0IsValid;                                                     /**< CubeStar raw telemetry valid flag  */
    U8 str0NumDetected;                                                      /**< Number of detected stars  */
    U8 str0NumIdentified;                                                    /**< Number of identified stars  */
    F64 str0RateX;                                                           /**< Estimated angular rate around CubeStar X-axis  (measurment unit is [deg/s]) */
    F64 str0RateY;                                                           /**< Estimated angular rate around CubeStar Y-axis  (measurment unit is [deg/s]) */
    F64 str0RateZ;                                                           /**< Estimated angular rate around CubeStar Z-axis  (measurment unit is [deg/s]) */
    TypesCubeComputerControlProgram8_StarCaptureStatus str1CaptureStatus;    /**< Status of image capture operation  */
    TypesCubeComputerControlProgram8_StarDetectStatus str1DetectStatus;      /**< Status of star detection operation  */
    TypesCubeComputerControlProgram8_StarIdStatus str1IdentStatus;           /**< Status of star identification operation  */
    Boolean str1Idle;                                                        /**< CubeStar is idle and can accept new command  */
    Boolean str1Tracking;                                                    /**< CubeStar is in tracking mode  */
    Boolean str1IsValid;                                                     /**< CubeStar raw telemetry valid flag  */
    U8 str1NumDetected;                                                      /**< Number of detected stars  */
    U8 str1NumIdentified;                                                    /**< Number of identified stars  */
    F64 str1RateX;                                                           /**< Estimated angular rate around CubeStar X-axis  (measurment unit is [deg/s]) */
    F64 str1RateY;                                                           /**< Estimated angular rate around CubeStar Y-axis  (measurment unit is [deg/s]) */
    F64 str1RateZ;                                                           /**< Estimated angular rate around CubeStar Z-axis  (measurment unit is [deg/s]) */
} TypesCubeComputerControlProgram8_TlmStrCubeStarRaw;

/**
 * @brief Raw CubeAuriga telemetry message structure
 * @details Raw CubeStar telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmStrCubeAurigaRawStruct {
    U32 timeSeconds;                                             /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                                                  /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    U16 str0FrameCnt;                                            /**< Frame count number  */
    U16 str0IDSATM;                                              /**< Sub-Address Identifier  */
    U16 str0SpecTC;                                              /**< Options of Telecommand  */
    U16 str0SyntDefATM;                                          /**< Synthesis of coherence tests results  */
    U16 str0SyntFusion;                                          /**< Synthesis of fused quaternion status  */
    U16 str0SyntFil;                                             /**< Synthesis of available quaternions for averaging of fused quaternion  */
    U32 str0DateMesFil;                                          /**< QRsFil measurement time  */
    F64 str0QRsFil1;                                             /**< Filtered fused attitude quaternion1 Rs/Rc  (valid range is between -1  and 1 ) */
    F64 str0QRsFil2;                                             /**< Filtered fused attitude quaternion2 Rs/Rc  (valid range is between -1  and 1 ) */
    F64 str0QRsFil3;                                             /**< Filtered fused attitude quaternion3 Rs/Rc  (valid range is between -1  and 1 ) */
    F64 str0QRsFil4;                                             /**< Filtered fused attitude quaternion4 Rs/Rc  (valid range is between -1  and 1 ) */
    U16 str0IQFilXRs;                                            /**< Quality index of the filtered attitude about XRs STR axis  */
    U16 str0IQFilYRs;                                            /**< Quality index of the filtered attitude about YRs STR axis  */
    U16 str0IQFilZRs;                                            /**< Quality index of the filtered attitude about ZRs STR axis  */
    U16 str0NbEtoAtt;                                            /**< Number of expected stars inside STR FOV  */
    U16 str0NbEtoAttOH;                                          /**< Number of expected stars per OH  */
    U16 str0NbEtoCoh;                                            /**< Number of used stars for fused attitude  */
    U16 str0NbEtoCohOH;                                          /**< Number of coherent stars per OH  */
    F32 str0WRsFil1;                                             /**< Filtered angular rate1 in Rs  */
    F32 str0WRsFil2;                                             /**< Filtered angular rate2 in Rs  */
    F32 str0WRsFil3;                                             /**< Filtered angular rate3 in Rs  (measurment unit is [rad/s]. valid range is between -2 rad/s and 2 rad/s) */
    U16 str0NLPMoyOH1;                                           /**< Mean level of stray-light for OH1  */
    U16 str0NLPMoyOH2;                                           /**< Mean level of stray-light for OH2  */
    U16 str0SyntFilOH1;                                          /**< Synthesis of available quaternions for averaging of OH1 quaternion  */
    U16 str0SyntFilOH2;                                          /**< Synthesis of available quaternions for averaging of OH2 quaternion  */
    U16 str0SyntFDIROH1;                                         /**< Synthesis of FDIR actions for OH1  */
    U16 str0SyntFDIROH2;                                         /**< Synthesis of FDIR actions for OH2  */
    U16 str0SyntDesOH1;                                          /**< Synthesis of OH1 designation  */
    U16 str0SyntDesOH2;                                          /**< Synthesis of OH2 designation  */
    TypesCubeComputerControlProgram8_OhStateVal str0OH1State;    /**< First Optical Head State  */
    TypesCubeComputerControlProgram8_OhStateVal str0OH2State;    /**< Second Optical Head State  */
    Boolean str0DataValid;                                       /**< Data is valid  */
    U16 str1FrameCnt;                                            /**< Frame count number  */
    U16 str1IDSATM;                                              /**< Sub-Address Identifier  */
    U16 str1SpecTC;                                              /**< Options of Telecommand  */
    U16 str1SyntDefATM;                                          /**< Synthesis of coherence tests results  */
    U16 str1SyntFusion;                                          /**< Synthesis of fused quaternion status  */
    U16 str1SyntFil;                                             /**< Synthesis of available quaternions for averaging of fused quaternion  */
    U32 str1DateMesFil;                                          /**< QRsFil measurement time  */
    F64 str1QRsFil1;                                             /**< Filtered fused attitude quaternion1 Rs/Rc  (valid range is between -1  and 1 ) */
    F64 str1QRsFil2;                                             /**< Filtered fused attitude quaternion2 Rs/Rc  (valid range is between -1  and 1 ) */
    F64 str1QRsFil3;                                             /**< Filtered fused attitude quaternion3 Rs/Rc  (valid range is between -1  and 1 ) */
    F64 str1QRsFil4;                                             /**< Filtered fused attitude quaternion4 Rs/Rc  (valid range is between -1  and 1 ) */
    U16 str1IQFilXRs;                                            /**< Quality index of the filtered attitude about XRs STR axis  */
    U16 str1IQFilYRs;                                            /**< Quality index of the filtered attitude about YRs STR axis  */
    U16 str1IQFilZRs;                                            /**< Quality index of the filtered attitude about ZRs STR axis  */
    U16 str1NbEtoAtt;                                            /**< Number of expected stars inside STR FOV  */
    U16 str1NbEtoAttOH;                                          /**< Number of expected stars per OH  */
    U16 str1NbEtoCoh;                                            /**< Number of used stars for fused attitude  */
    U16 str1NbEtoCohOH;                                          /**< Number of coherent stars per OH  */
    F32 str1WRsFil1;                                             /**< Filtered angular rate1 in Rs  */
    F32 str1WRsFil2;                                             /**< Filtered angular rate2 in Rs  */
    F32 str1WRsFil3;                                             /**< Filtered angular rate3 in Rs  (measurment unit is [rad/s]. valid range is between -2 rad/s and 2 rad/s) */
    U16 str1NLPMoyOH1;                                           /**< Mean level of stray-light for OH1  */
    U16 str1NLPMoyOH2;                                           /**< Mean level of stray-light for OH2  */
    U16 str1SyntFilOH1;                                          /**< Synthesis of available quaternions for averaging of OH1 quaternion  */
    U16 str1SyntFilOH2;                                          /**< Synthesis of available quaternions for averaging of OH2 quaternion  */
    U16 str1SyntFDIROH1;                                         /**< Synthesis of FDIR actions for OH1  */
    U16 str1SyntFDIROH2;                                         /**< Synthesis of FDIR actions for OH2  */
    U16 str1SyntDesOH1;                                          /**< Synthesis of OH1 designation  */
    U16 str1SyntDesOH2;                                          /**< Synthesis of OH2 designation  */
    TypesCubeComputerControlProgram8_OhStateVal str1OH1State;    /**< First Optical Head State  */
    TypesCubeComputerControlProgram8_OhStateVal str1OH2State;    /**< Second Optical Head State  */
    Boolean str1DataValid;                                       /**< Data is valid  */
} TypesCubeComputerControlProgram8_TlmStrCubeAurigaRaw;

/**
 * @brief Raw NSSRWL sensor telemetry message structure
 * @details Raw NSSRWL sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmRwlNssRwlRawStruct {
    U32 timeSeconds;               /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                    /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    S16 rwl0TargetValue;           /**< RWL0 target value  */
    F32 rwl0MeasSpeed;             /**< RWL0 measured speed  (measurment unit is [rpm]. valid range is between -10000 rpm and 10000 rpm) */
    S16 rwl0MeasCurrent;           /**< RWL0 measured current  (measurment unit is [mA]) */
    S16 rwl0Temp;                  /**< RWL0 NSSRWL temperature (not CubeNode)  (measurment unit is [C]) */
    S16 rwl1TargetValue;           /**< RWL1 target value  */
    F32 rwl1MeasSpeed;             /**< RWL1 measured speed  (measurment unit is [rpm]. valid range is between -10000 rpm and 10000 rpm) */
    S16 rwl1MeasCurrent;           /**< RWL1 measured current  (measurment unit is [mA]) */
    S16 rwl1Temp;                  /**< RWL1 NSSRWL temperature (not CubeNode)  (measurment unit is [C]) */
    S16 rwl2TargetValue;           /**< RWL2 target value  */
    F32 rwl2MeasSpeed;             /**< RWL2 measured speed  (measurment unit is [rpm]. valid range is between -10000 rpm and 10000 rpm) */
    S16 rwl2MeasCurrent;           /**< RWL2 measured current  (measurment unit is [mA]) */
    S16 rwl2Temp;                  /**< RWL2 NSSRWL temperature (not CubeNode)  (measurment unit is [C]) */
    S16 rwl3TargetValue;           /**< RWL3 target value  */
    F32 rwl3MeasSpeed;             /**< RWL3 measured speed  (measurment unit is [rpm]. valid range is between -10000 rpm and 10000 rpm) */
    S16 rwl3MeasCurrent;           /**< RWL3 measured current  (measurment unit is [mA]) */
    S16 rwl3Temp;                  /**< RWL3 NSSRWL temperature (not CubeNode)  (measurment unit is [C]) */
    Boolean rwl0IsValid;           /**< RWL0 valid flag  */
    Boolean rwl0WheelMode;         /**< RWL0 Set if in reaction wheel mode  */
    Boolean rwl0CurentCtrlMode;    /**< RWL0 Set if in current-control mode  */
    Boolean rwl0SpeedCtrlMode;     /**< RWL0 Set if in speed-control mode  */
    Boolean rwl0TorqueCtrlMode;    /**< RWL0 Set if in torque-control mode  */
    Boolean rwl0CrcError;          /**< RWL0 Set if CRC error on protected area  */
    Boolean rwl0WrongLlCmd;        /**< RWL0 wrong low-level command  */
    Boolean rwl0WrongHlCmd;        /**< RWL0 wrong high-level command  */
    Boolean rwl0ToutSci1Main;      /**< RWL0 Timeout on SCI1 main interface  */
    Boolean rwl1IsValid;           /**< RWL1 valid flag  */
    Boolean rwl1WheelMode;         /**< RWL1 Set if in reaction wheel mode  */
    Boolean rwl1CurentCtrlMode;    /**< RWL1 Set if in current-control mode  */
    Boolean rwl1SpeedCtrlMode;     /**< RWL1 Set if in speed-control mode  */
    Boolean rwl1TorqueCtrlMode;    /**< RWL1 Set if in torque-control mode  */
    Boolean rwl1CrcError;          /**< RWL1 Set if CRC error on protected area  */
    Boolean rwl1WrongLlCmd;        /**< RWL1 wrong low-level command  */
    Boolean rwl1WrongHlCmd;        /**< RWL1 wrong high-level command  */
    Boolean rwl1ToutSci1Main;      /**< RWL1 Timeout on SCI1 main interface  */
    Boolean rwl2IsValid;           /**< RWL2 valid flag  */
    Boolean rwl2WheelMode;         /**< RWL2 Set if in reaction wheel mode  */
    Boolean rwl2CurentCtrlMode;    /**< RWL2 Set if in current-control mode  */
    Boolean rwl2SpeedCtrlMode;     /**< RWL2 Set if in speed-control mode  */
    Boolean rwl2TorqueCtrlMode;    /**< RWL2 Set if in torque-control mode  */
    Boolean rwl2CrcError;          /**< RWL2 Set if CRC error on protected area  */
    Boolean rwl2WrongLlCmd;        /**< RWL2 wrong low-level command  */
    Boolean rwl2WrongHlCmd;        /**< RWL2 wrong high-level command  */
    Boolean rwl2ToutSci1Main;      /**< RWL2 Timeout on SCI1 main interface  */
    Boolean rwl3IsValid;           /**< RWL3 valid flag  */
    Boolean rwl3WheelMode;         /**< RWL3 Set if in reaction wheel mode  */
    Boolean rwl3CurentCtrlMode;    /**< RWL3 Set if in current-control mode  */
    Boolean rwl3SpeedCtrlMode;     /**< RWL3 Set if in speed-control mode  */
    Boolean rwl3TorqueCtrlMode;    /**< RWL3 Set if in torque-control mode  */
    Boolean rwl3CrcError;          /**< RWL3 Set if CRC error on protected area  */
    Boolean rwl3WrongLlCmd;        /**< RWL3 wrong low-level command  */
    Boolean rwl3WrongHlCmd;        /**< RWL3 wrong high-level command  */
    Boolean rwl3ToutSci1Main;      /**< RWL3 Timeout on SCI1 main interface  */
} TypesCubeComputerControlProgram8_TlmRwlNssRwlRaw;

/**
 * @brief RAW LITEF uFORS sensor telemetry message structure
 * @details Raw LITEF uFORS sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmGyrLitefuforsRawStruct {
    U32 timeSeconds;                        /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                             /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F32 gyr0RateUfors1;                     /**< EXTGYR0 axis-1 Angular rate  (valid range is between -20  and 20 ) */
    F32 gyr0RateUfors2;                     /**< EXTGYR0 axis-2  Angular rate  (valid range is between -20  and 20 ) */
    F32 gyr0RateUfors3;                     /**< EXTGYR0 axis-3  Angular rate  (valid range is between -20  and 20 ) */
    Boolean gyr0NogoUfors1;                 /**< EXTGYR0 axis-1 Status - NOGO bit  */
    Boolean gyr0RstAckUfors1;               /**< EXTGYR0 axis-1 Status - Reset acknowledge bit  */
    Boolean gyr0TempWarnUfors1;             /**< EXTGYR0 axis-1 Status - temperature warning bit  */
    Boolean gyr0AuxControlLoopErrUfors1;    /**< EXTGYR0 axis-1 Status - auxillary control loop error bit  */
    Boolean gyr0HardBitErrUfors1;           /**< EXTGYR0 axis-1 Status - Hardware BIT error bit  */
    Boolean gyr0MeasRangeErrUfors1;         /**< EXTGYR0 axis-1 Status - Measurement range exceeded bit  */
    Boolean gyr0UnknwnCmdUfors1;            /**< EXTGYR0 axis-1 Status - unknown command bit  */
    Boolean gyr0NogoUfors2;                 /**< EXTGYR0 axis-2  Status - NOGO bit  */
    Boolean gyr0RstAckUfors2;               /**< EXTGYR0 axis-2  Status - Reset acknowledge bit  */
    Boolean gyr0TempWarnUfors2;             /**< EXTGYR0 axis-2  Status - temperature warning bit  */
    Boolean gyr0AuxControlLoopErrUfors2;    /**< EXTGYR0 axis-2  Status - auxillary control loop error bit  */
    Boolean gyr0HardBitErrUfors2;           /**< EXTGYR0 axis-2  Status - Hardware BIT error bit  */
    Boolean gyr0MeasRangeErrUfors2;         /**< EXTGYR0 axis-2  Status - Measurement range exceeded bit  */
    Boolean gyr0UnknwnCmdUfors2;            /**< EXTGYR0 axis-2  Status - unknown command bit  */
    Boolean gyr0NogoUfors3;                 /**< EXTGYR0 axis-3  Status - NOGO bit  */
    Boolean gyr0RstAckUfors3;               /**< EXTGYR0 axis-3  Status - Reset acknowledge bit  */
    Boolean gyr0TempWarnUfors3;             /**< EXTGYR0 axis-3  Status - temperature warning bit  */
    Boolean gyr0AuxControlLoopErrUfors3;    /**< EXTGYR0 axis-3  Status - auxillary control loop error bit  */
    Boolean gyr0HardBitErrUfors3;           /**< EXTGYR0 axis-3  Status - Hardware BIT error bit  */
    Boolean gyr0MeasRangeErrUfors3;         /**< EXTGYR0 axis-3  Status - Measurement range exceeded bit  */
    Boolean gyr0UnknwnCmdUfors3;            /**< EXTGYR0 axis-3  Status - unknown command bit  */
    F32 gyr1RateUfors1;                     /**< EXTGYR1 axis-1 Angular rate  (valid range is between -20  and 20 ) */
    F32 gyr1RateUfors2;                     /**< EXTGYR1 axis-2  Angular rate  (valid range is between -20  and 20 ) */
    F32 gyr1RateUfors3;                     /**< EXTGYR1 axis-3  Angular rate  (valid range is between -20  and 20 ) */
    Boolean gyr1NogoUfors1;                 /**< EXTGYR1 axis-1Status - NOGO bit  */
    Boolean gyr1RstAckUfors1;               /**< EXTGYR1 axis-1 Status - Reset acknowledge bit  */
    Boolean gyr1TempWarnUfors1;             /**< EXTGYR1 axis-1 Status - temperature warning bit  */
    Boolean gyr1AuxControlLoopErrUfors1;    /**< EXTGYR1 axis-1 Status - auxillary control loop error bit  */
    Boolean gyr1HardBitErrUfors1;           /**< EXTGYR1 axis-1 Status - Hardware BIT error bit  */
    Boolean gyr1MeasRangeErrUfors1;         /**< EXTGYR1 axis-1 Status - Measurement range exceeded bit  */
    Boolean gyr1UnknwnCmdUfors1;            /**< EXTGYR1 axis-1 Status - unknown command bit  */
    Boolean gyr1NogoUfors2;                 /**< EXTGYR1 axis-2  Status - NOGO bit  */
    Boolean gyr1RstAckUfors2;               /**< EXTGYR1 axis-2  Status - Reset acknowledge bit  */
    Boolean gyr1TempWarnUfors2;             /**< EXTGYR1 axis-2  Status - temperature warning bit  */
    Boolean gyr1AuxControlLoopErrUfors2;    /**< EXTGYR1 axis-2  Status - auxillary control loop error bit  */
    Boolean gyr1HardBitErrUfors2;           /**< EXTGYR1 axis-2  Status - Hardware BIT error bit  */
    Boolean gyr1MeasRangeErrUfors2;         /**< EXTGYR1 axis-2  Status - Measurement range exceeded bit  */
    Boolean gyr1UnknwnCmdUfors2;            /**< EXTGYR1 axis-2  Status - unknown command bit  */
    Boolean gyr1NogoUfors3;                 /**< EXTGYR1 axis-3  Status - NOGO bit  */
    Boolean gyr1RstAckUfors3;               /**< EXTGYR1 axis-3  Status - Reset acknowledge bit  */
    Boolean gyr1TempWarnUfors3;             /**< EXTGYR1 axis-3  Status - temperature warning bit  */
    Boolean gyr1AuxControlLoopErrUfors3;    /**< EXTGYR1 axis-3  Status - auxillary control loop error bit  */
    Boolean gyr1HardBitErrUfors3;           /**< EXTGYR1 axis-3  Status - Hardware BIT error bit  */
    Boolean gyr1MeasRangeErrUfors3;         /**< EXTGYR1 axis-3  Status - Measurement range exceeded bit  */
    Boolean gyr1UnknwnCmdUfors3;            /**< EXTGYR1 axis-3  Status - unknown command bit  */
} TypesCubeComputerControlProgram8_TlmGyrLitefuforsRaw;

/**
 * @brief Calibrated FSS sensor telemetry message structure
 * @details Calibrated FSS sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorCalFssStruct {
    U32 timeSeconds;        /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;             /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 fss0CalVecX;        /**< FSS0 calibrated unit vector X component  */
    F64 fss0CalVecY;        /**< FSS0 calibrated unit vector Y component  */
    F64 fss0CalVecZ;        /**< FSS0 calibrated unit vector Z component  */
    F64 fss1CalVecX;        /**< FSS1 calibrated unit vector X component  */
    F64 fss1CalVecY;        /**< FSS1 calibrated unit vector Y component  */
    F64 fss1CalVecZ;        /**< FSS1 calibrated unit vector Z component  */
    F64 fss2CalVecX;        /**< FSS2 calibrated unit vector X component  */
    F64 fss2CalVecY;        /**< FSS2 calibrated unit vector Y component  */
    F64 fss2CalVecZ;        /**< FSS2 calibrated unit vector Z component  */
    F64 fss3CalVecX;        /**< FSS3 calibrated unit vector X component  */
    F64 fss3CalVecY;        /**< FSS3 calibrated unit vector Y component  */
    F64 fss3CalVecZ;        /**< FSS3 calibrated unit vector Z component  */
    Boolean fss0IsValid;    /**< FSS0 valid flag  */
    Boolean fss1IsValid;    /**< FSS1 valid flag  */
    Boolean fss2IsValid;    /**< FSS2 valid flag  */
    Boolean fss3IsValid;    /**< FSS3 valid flag  */
    Boolean fss0IsBest;     /**< FSS0 best for estimators flag  */
    Boolean fss1IsBest;     /**< FSS1 best for estimators flag  */
    Boolean fss2IsBest;     /**< FSS2 best for estimators flag  */
    Boolean fss3IsBest;     /**< FSS3 best for estimators flag  */
} TypesCubeComputerControlProgram8_TlmSensorCalFss;

/**
 * @brief Calibrated CSS sensor telemetry message structure
 * @details Calibrated CSS sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorCalCssStruct {
    U32 timeSeconds;       /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;            /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 cssCalVecX;        /**< CSS calibrated unit vector X component  */
    F64 cssCalVecY;        /**< CSS calibrated unit vector Y component  */
    F64 cssCalVecZ;        /**< CSS calibrated unit vector Z component  */
    Boolean cssIsValid;    /**< CSS valid flag  */
} TypesCubeComputerControlProgram8_TlmSensorCalCss;

/**
 * @brief Calibrated MAG sensor telemetry message structure
 * @details Calibrated MAG sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorCalMagStruct {
    U32 timeSeconds;        /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;             /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 mag0CalVecX;        /**< MAG0 calibrated vector X component  (measurment unit is [uT]) */
    F64 mag0CalVecY;        /**< MAG0 calibrated vector Y component  (measurment unit is [uT]) */
    F64 mag0CalVecZ;        /**< MAG0 calibrated vector Z component  (measurment unit is [uT]) */
    F64 mag1CalVecX;        /**< MAG1 calibrated vector X component  (measurment unit is [uT]) */
    F64 mag1CalVecY;        /**< MAG1 calibrated vector Y component  (measurment unit is [uT]) */
    F64 mag1CalVecZ;        /**< MAG1 calibrated vector Z component  (measurment unit is [uT]) */
    Boolean mag0IsValid;    /**< MAG0 valid flag  */
    Boolean mag1IsValid;    /**< MAG1 valid flag  */
    Boolean mag0IsBest;     /**< MAG0 best for estimators flag  */
    Boolean mag1IsBest;     /**< MAG1 best for estimators flag  */
} TypesCubeComputerControlProgram8_TlmSensorCalMag;

/**
 * @brief Calibrated GYR sensor telemetry message structure
 * @details Calibrated GYRO sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorCalGyroStruct {
    U32 timeSeconds;            /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                 /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F32 gyro0CalRateX;          /**< GYR0 calibrated rate X component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro0CalRateY;          /**< GYR0 calibrated rate Y component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro0CalRateZ;          /**< GYR0 calibrated rate Z component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro1CalRateX;          /**< GYR1 calibrated rate X component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro1CalRateY;          /**< GYR1 calibrated rate Y component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro1CalRateZ;          /**< GYR1 calibrated rate Z component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 extGyro0CalRateX;       /**< EXTGYR0 calibrated rate X component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 extGyro0CalRateY;       /**< EXTGYR0 calibrated rate Y component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 extGyro0CalRateZ;       /**< EXTGYR0 calibrated rate Z component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 extGyro1CalRateX;       /**< EXTGYR1 calibrated rate X component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 extGyro1CalRateY;       /**< EXTGYR1 calibrated rate Y component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 extGyro1CalRateZ;       /**< EXTGYR1 calibrated rate Z component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    Boolean gyro0IsValid;       /**< GYR0 valid flag  */
    Boolean gyro1IsValid;       /**< GYR1 valid flag  */
    Boolean extGyro0IsValid;    /**< EXTGYR0 valid flag  */
    Boolean extGyro1IsValid;    /**< EXTGYR1 valid flag  */
} TypesCubeComputerControlProgram8_TlmSensorCalGyro;

/**
 * @brief Calibrated HSS sensor telemetry message structure
 * @details Calibrated HSS sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorCalHssStruct {
    U32 timeSeconds;        /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;             /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 hss0CalVecX;        /**< HSS0 calibrated unit vector X component  */
    F64 hss0CalVecY;        /**< HSS0 calibrated unit vector Y component  */
    F64 hss0CalVecZ;        /**< HSS0 calibrated unit vector Z component  */
    F64 hss1CalVecX;        /**< HSS1 calibrated unit vector X component  */
    F64 hss1CalVecY;        /**< HSS1 calibrated unit vector Y component  */
    F64 hss1CalVecZ;        /**< HSS1 calibrated unit vector Z component  */
    Boolean hss0IsValid;    /**< HSS0 valid flag  */
    Boolean hss1IsValid;    /**< HSS1 valid flag  */
} TypesCubeComputerControlProgram8_TlmSensorCalHss;

/**
 * @brief Calibrated STR sensor telemetry message structure
 * @details Calibrated STR sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorCalStrStruct {
    U32 timeSeconds;            /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                 /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 str0MeasBodyVec0X;      /**< STR0 measured body vector 0 X component  */
    F64 str0MeasBodyVec0Y;      /**< STR0 measured body vector 0 Y component  */
    F64 str0MeasBodyVec0Z;      /**< STR0 measured body vector 0 Z component  */
    F64 str0MeasBodyVec1X;      /**< STR0 measured body vector 1 X component  */
    F64 str0MeasBodyVec1Y;      /**< STR0 measured body vector 1 Y component  */
    F64 str0MeasBodyVec1Z;      /**< STR0 measured body vector 1 Z component  */
    F64 str0MeasBodyVec2X;      /**< STR0 measured body vector 2 X component  */
    F64 str0MeasBodyVec2Y;      /**< STR0 measured body vector 2 Y component  */
    F64 str0MeasBodyVec2Z;      /**< STR0 measured body vector 2 Z component  */
    F64 str0ModelOrbitVec0X;    /**< STR0 modelled ORC vector 0 X component  */
    F64 str0ModelOrbitVec0Y;    /**< STR0 modelled ORC vector 0 Y component  */
    F64 str0ModelOrbitVec0Z;    /**< STR0 modelled ORC vector 0 Z component  */
    F64 str0ModelOrbitVec1X;    /**< STR0 modelled ORC vector 1 X component  */
    F64 str0ModelOrbitVec1Y;    /**< STR0 modelled ORC vector 1 Y component  */
    F64 str0ModelOrbitVec1Z;    /**< STR0 modelled ORC vector 1 Z component  */
    F64 str0ModelOrbitVec2X;    /**< STR0 modelled ORC vector 2 X component  */
    F64 str0ModelOrbitVec2Y;    /**< STR0 modelled ORC vector 2 Y component  */
    F64 str0ModelOrbitVec2Z;    /**< STR0 modelled ORC vector 2 Z component  */
    F64 str1MeasBodyVec0X;      /**< STR1 measured body vector 0 X component  */
    F64 str1MeasBodyVec0Y;      /**< STR1 measured body vector 0 Y component  */
    F64 str1MeasBodyVec0Z;      /**< STR1 measured body vector 0 Z component  */
    F64 str1MeasBodyVec1X;      /**< STR1 measured body vector 1 X component  */
    F64 str1MeasBodyVec1Y;      /**< STR1 measured body vector 1 Y component  */
    F64 str1MeasBodyVec1Z;      /**< STR1 measured body vector 1 Z component  */
    F64 str1MeasBodyVec2X;      /**< STR1 measured body vector 2 X component  */
    F64 str1MeasBodyVec2Y;      /**< STR1 measured body vector 2 Y component  */
    F64 str1MeasBodyVec2Z;      /**< STR1 measured body vector 2 Z component  */
    F64 str1ModelOrbitVec0X;    /**< STR1 modelled ORC vector 0 X component  */
    F64 str1ModelOrbitVec0Y;    /**< STR1 modelled ORC vector 0 Y component  */
    F64 str1ModelOrbitVec0Z;    /**< STR1 modelled ORC vector 0 Z component  */
    F64 str1ModelOrbitVec1X;    /**< STR1 modelled ORC vector 1 X component  */
    F64 str1ModelOrbitVec1Y;    /**< STR1 modelled ORC vector 1 Y component  */
    F64 str1ModelOrbitVec1Z;    /**< STR1 modelled ORC vector 1 Z component  */
    F64 str1ModelOrbitVec2X;    /**< STR1 modelled ORC vector 2 X component  */
    F64 str1ModelOrbitVec2Y;    /**< STR1 modelled ORC vector 2 Y component  */
    F64 str1ModelOrbitVec2Z;    /**< STR1 modelled ORC vector 2 Z component  */
    Boolean str0IsValid;        /**< STR0 valid flag  */
    Boolean str1IsValid;        /**< STR1 valid flag  */
} TypesCubeComputerControlProgram8_TlmSensorCalStr;

/**
 * @brief Calibrated GNSS sensor telemetry message structure
 * @details Calibrated GNSS sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorCalGnssStruct {
    U32 timeSeconds;        /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;             /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F32 gnssSatPosEcefX;    /**< Satellite ECEF position vector X component  (measurment unit is [m]) */
    F32 gnssSatPosEcefY;    /**< Satellite ECEF position vector Y component  (measurment unit is [m]) */
    F32 gnssSatPosEcefZ;    /**< Satellite ECEF position vector Z component  (measurment unit is [m]) */
    F32 gnssSatVelEcefX;    /**< Satellite ECEF velocity vector X component  (measurment unit is [m/s]) */
    F32 gnssSatVelEcefY;    /**< Satellite ECEF velocity vector Y component  (measurment unit is [m/s]) */
    F32 gnssSatVelEcefZ;    /**< Satellite ECEF velocity vector Z component  (measurment unit is [m/s]) */
    U32 gnssTimeSeconds;    /**< GNSS-supplied unix time integer seconds  (measurment unit is [s]) */
    U32 gnssTimeNs;         /**< GNSS-supplied unix time nanoseconds  (measurment unit is [ns]) */
    Boolean gnssIsValid;    /**< GNSS valid flag  */
} TypesCubeComputerControlProgram8_TlmSensorCalGnss;

/**
 * @brief Calibrated RWL sensor telemetry message structure
 * @details Calibrated RWL sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmSensorCalRwlStruct {
    U32 timeSeconds;       /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;            /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F32 rwlTorqueVecX;     /**< Wheel SBC torque vector X component  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F32 rwlTorqueVecY;     /**< Wheel SBC torque vector Y component  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F32 rwlTorqueVecZ;     /**< Wheel SBC torque vector Z component  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F32 rwlMomVecX;        /**< Wheel SBC momentum vector X component  (measurment unit is [N.m.s]. valid range is between -10 N.m.s and 10 N.m.s) */
    F32 rwlMomVecY;        /**< Wheel SBC momentum vector Y component  (measurment unit is [N.m.s]. valid range is between -10 N.m.s and 10 N.m.s) */
    F32 rwlMomVecZ;        /**< Wheel SBC momentum vector Z component  (measurment unit is [N.m.s]. valid range is between -10 N.m.s and 10 N.m.s) */
    Boolean rwlIsValid;    /**< RWL valid flag  */
} TypesCubeComputerControlProgram8_TlmSensorCalRwl;

/**
 * @brief Models telemetry message structure
 * @details Models telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmModelsStruct {
    U32 timeSeconds;                                                 /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                                                      /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    S32 satPosEciX;                                                  /**< Satellite ECI position vector X component  (measurment unit is [m]) */
    S32 satPosEciY;                                                  /**< Satellite ECI position vector Y component  (measurment unit is [m]) */
    S32 satPosEciZ;                                                  /**< Satellite ECI position vector Z component  (measurment unit is [m]) */
    S16 satVelEciX;                                                  /**< Satellite ECI velocity vector X component  (measurment unit is [m/s]) */
    S16 satVelEciY;                                                  /**< Satellite ECI velocity vector Y component  (measurment unit is [m/s]) */
    S16 satVelEciZ;                                                  /**< Satellite ECI velocity vector Z component  (measurment unit is [m/s]) */
    F64 satLatGeod;                                                  /**< Satellite geodetic latitude  (measurment unit is [deg]) */
    F64 satLatGeoc;                                                  /**< Satellite geocentric latitude  (measurment unit is [deg]) */
    F64 satLon;                                                      /**< Satellite longitude  (measurment unit is [deg]) */
    F64 satAlt;                                                      /**< Satellite altitude  (measurment unit is [km]) */
    S32 tgtPosEciX;                                                  /**< Target satellite ECI position vector X component  (measurment unit is [m]) */
    S32 tgtPosEciY;                                                  /**< Target satellite ECI position vector Y component  (measurment unit is [m]) */
    S32 tgtPosEciZ;                                                  /**< Target satellite ECI position vector Z component  (measurment unit is [m]) */
    F64 modelMagOrcX;                                                /**< IGRF ORC model X component  (measurment unit is [uT]) */
    F64 modelMagOrcY;                                                /**< IGRF ORC model Y component  (measurment unit is [uT]) */
    F64 modelMagOrcZ;                                                /**< IGRF ORC model Z component  (measurment unit is [uT]) */
    F64 modelSunOrcX;                                                /**< Sun ORC model X component  */
    F64 modelSunOrcY;                                                /**< Sun ORC model Y component  */
    F64 modelSunOrcZ;                                                /**< Sun ORC model Z component  */
    F64 modelSunBetaAngle;                                           /**< Sun beta angle with orbit plane  (measurment unit is [deg]) */
    F64 modelHorRhoAngle;                                            /**< Horizon angle in XoYo plane  (measurment unit is [deg]) */
    F64 modelHorXoEastAngle;                                         /**< Horizon East angle from Xo direction  (measurment unit is [deg]) */
    F64 modelHorYiEastAngle;                                         /**< Horizon East angle from Yi direction  (measurment unit is [deg]) */
    S32 sat2TgtGndOrcX;                                              /**< Satellite to ground ORC target vector X component  (measurment unit is [m]) */
    S32 sat2TgtGndOrcY;                                              /**< Satellite to ground ORC target vector Y component  (measurment unit is [m]) */
    S32 sat2TgtGndOrcZ;                                              /**< Satellite to ground ORC target vector Z component  (measurment unit is [m]) */
    U16 asgp4BatchCtr;                                               /**< ASGP4 batch counter  */
    U16 asgp4PosDelta;                                               /**< Average position error between GNSS and ASGP4  (measurment unit is [m]) */
    TypesCubeComputerControlProgram8_OrbModeSelect orbModeActive;    /**< Active orbit mode  */
    Boolean asgp4Error;                                              /**< GNSS and ASGP4 position error differs too much  */
    Boolean eclipse;                                                 /**< Eclipse flag  */
    TypesCubeComputerControlProgram8_NavSource navSource;            /**< Source of current orbit position and velocity  */
} TypesCubeComputerControlProgram8_TlmModels;

/**
 * @brief Main estimator telemetry message structure
 * @details Main estimator telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmEstimatorMainStruct {
    U32 timeSeconds;                                                 /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                                                      /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 estRpyRoll;                                                  /**< Estimated roll angle  (measurment unit is [deg]) */
    F64 estRpyPitch;                                                 /**< Estimated pitch angle  (measurment unit is [deg]) */
    F64 estRpyYaw;                                                   /**< Estimated yaw angle  (measurment unit is [deg]) */
    F64 estQuatQ0;                                                   /**< Estimated ORC quaternion Q0  */
    F64 estQuatQ1;                                                   /**< Estimated ORC quaternion Q1  */
    F64 estQuatQ2;                                                   /**< Estimated ORC quaternion Q2  */
    F64 estQuatQ3;                                                   /**< Estimated ORC quaternion Q3  */
    F64 estGyroBiasX;                                                /**< Estimated gyro bias X component  (measurment unit is [degps]) */
    F64 estGyroBiasY;                                                /**< Estimated gyro bias Y component  (measurment unit is [degps]) */
    F64 estGyroBiasZ;                                                /**< Estimated gyro bias Z component  (measurment unit is [degps]) */
    F64 estRateOrcX;                                                 /**< Estimated body rate (ORC) X component  (measurment unit is [degps]) */
    F64 estRateOrcY;                                                 /**< Estimated body rate (ORC) Y component  (measurment unit is [degps]) */
    F64 estRateOrcZ;                                                 /**< Estimated body rate (ORC) Z component  (measurment unit is [degps]) */
    F64 estRateIrcX;                                                 /**< Estimated body rate (IRC) X component  (measurment unit is [degps]) */
    F64 estRateIrcY;                                                 /**< Estimated body rate (IRC) Y component  (measurment unit is [degps]) */
    F64 estRateIrcZ;                                                 /**< Estimated body rate (IRC) Z component  (measurment unit is [degps]) */
    F32 estGyrTorqueX;                                               /**< Estimated gyroscopic torque X component  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F32 estGyrTorqueY;                                               /**< Estimated gyroscopic torque Y component  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F32 estGyrTorqueZ;                                               /**< Estimated gyroscopic torque Z component  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F64 estInnovX;                                                   /**< Innovation vector X component  */
    F64 estInnovY;                                                   /**< Innovation vector Y component  */
    F64 estInnovZ;                                                   /**< Innovation vector Z component  */
    F64 estStdDevRateX;                                              /**< StdDev of estimated rate X component  (measurment unit is [degps]) */
    F64 estStdDevRateY;                                              /**< StdDev of estimated rate Y component  (measurment unit is [degps]) */
    F64 estStdDevRateZ;                                              /**< StdDev of estimated rate Z component  (measurment unit is [degps]) */
    F64 estStdDevQ0;                                                 /**< StdDev of estimated quaternion Q0 component  */
    F64 estStdDevQ1;                                                 /**< StdDev of estimated quaternion Q1 component  */
    F64 estStdDevQ2;                                                 /**< StdDev of estimated quaternion Q2 component  */
    TypesCubeComputerControlProgram8_EstModeSelect estModeActive;    /**< Active estimator mode  */
} TypesCubeComputerControlProgram8_TlmEstimatorMain;

/**
 * @brief Backup estimator telemetry message structure
 * @details Backup estimator telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmEstimatorBackupStruct {
    U32 timeSeconds;                                                 /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                                                      /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 estRpyRoll;                                                  /**< Estimated roll angle  (measurment unit is [deg]) */
    F64 estRpyPitch;                                                 /**< Estimated pitch angle  (measurment unit is [deg]) */
    F64 estRpyYaw;                                                   /**< Estimated yaw angle  (measurment unit is [deg]) */
    F64 estQuatQ0;                                                   /**< Estimated ORC quaternion Q0  */
    F64 estQuatQ1;                                                   /**< Estimated ORC quaternion Q1  */
    F64 estQuatQ2;                                                   /**< Estimated ORC quaternion Q2  */
    F64 estQuatQ3;                                                   /**< Estimated ORC quaternion Q3  */
    F64 estGyroBiasX;                                                /**< Estimated gyro bias X component  (measurment unit is [degps]) */
    F64 estGyroBiasY;                                                /**< Estimated gyro bias Y component  (measurment unit is [degps]) */
    F64 estGyroBiasZ;                                                /**< Estimated gyro bias Z component  (measurment unit is [degps]) */
    F64 estRateOrcX;                                                 /**< Estimated body rate (ORC) X component  (measurment unit is [degps]) */
    F64 estRateOrcY;                                                 /**< Estimated body rate (ORC) Y component  (measurment unit is [degps]) */
    F64 estRateOrcZ;                                                 /**< Estimated body rate (ORC) Z component  (measurment unit is [degps]) */
    F64 estRateIrcX;                                                 /**< Estimated body rate (IRC) X component  (measurment unit is [degps]) */
    F64 estRateIrcY;                                                 /**< Estimated body rate (IRC) Y component  (measurment unit is [degps]) */
    F64 estRateIrcZ;                                                 /**< Estimated body rate (IRC) Z component  (measurment unit is [degps]) */
    F32 estGyrTorqueX;                                               /**< Estimated gyroscopic torque X component  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F32 estGyrTorqueY;                                               /**< Estimated gyroscopic torque Y component  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F32 estGyrTorqueZ;                                               /**< Estimated gyroscopic torque Z component  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F64 estInnovX;                                                   /**< Innovation vector X component  */
    F64 estInnovY;                                                   /**< Innovation vector Y component  */
    F64 estInnovZ;                                                   /**< Innovation vector Z component  */
    F64 estStdDevRateX;                                              /**< StdDev of estimated rate X component  (measurment unit is [degps]) */
    F64 estStdDevRateY;                                              /**< StdDev of estimated rate Y component  (measurment unit is [degps]) */
    F64 estStdDevRateZ;                                              /**< StdDev of estimated rate Z component  (measurment unit is [degps]) */
    F64 estStdDevQ0;                                                 /**< StdDev of estimated quaternion Q0 component  */
    F64 estStdDevQ1;                                                 /**< StdDev of estimated quaternion Q1 component  */
    F64 estStdDevQ2;                                                 /**< StdDev of estimated quaternion Q2 component  */
    TypesCubeComputerControlProgram8_EstModeSelect estModeActive;    /**< Active estimator mode  */
} TypesCubeComputerControlProgram8_TlmEstimatorBackup;

/**
 * @brief Main estimator high-resolution telemetry message structure
 * @details Main estimator high-resolution telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmEstimatorMainHighResStruct {
    U32 timeSeconds;    /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;         /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F32 estQuatQ0;      /**< Estimated ORC quaternion Q0  (valid range is between -1  and 1 ) */
    F32 estQuatQ1;      /**< Estimated ORC quaternion Q1  (valid range is between -1  and 1 ) */
    F32 estQuatQ2;      /**< Estimated ORC quaternion Q2  (valid range is between -1  and 1 ) */
    F32 estQuatQ3;      /**< Estimated ORC quaternion Q3  (valid range is between -1  and 1 ) */
    F32 estRateOrcX;    /**< Estimated body rate (ORC) X component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 estRateOrcY;    /**< Estimated body rate (ORC) Y component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 estRateOrcZ;    /**< Estimated body rate (ORC) Z component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
} TypesCubeComputerControlProgram8_TlmEstimatorMainHighRes;

/**
 * @brief Controller telemetry message structure
 * @details Controller telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmControllerStruct {
    U32 timeSeconds;                                                 /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                                                      /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 rpyCmdRoll;                                                  /**< Commanded roll angle  (measurment unit is [deg]) */
    F64 rpyCmdPitch;                                                 /**< Commanded pitch angle  (measurment unit is [deg]) */
    F64 rpyCmdYaw;                                                   /**< Commanded yaw angle  (measurment unit is [deg]) */
    F64 rpyErrRoll;                                                  /**< Error roll angle (steering)  (measurment unit is [deg]) */
    F64 rpyErrPitch;                                                 /**< Error pitch angle (steering)  (measurment unit is [deg]) */
    F64 rpyErrYaw;                                                   /**< Error yaw angle (steering)  (measurment unit is [deg]) */
    F32 tgtRefLat;                                                   /**< Reference ground/GEO target latitude  (measurment unit is [deg]. valid range is between -90 deg and 90 deg) */
    F32 tgtRefLon;                                                   /**< Reference ground/GEO target longitude  (measurment unit is [deg]. valid range is between -180 deg and 180 deg) */
    F32 tgtRefAlt;                                                   /**< Reference ground/GEO target altitude  (measurment unit is [km]) */
    F64 quatErrQ0;                                                   /**< Control error quaternion vector Q0  */
    F64 quatErrQ1;                                                   /**< Control error quaternion vector Q1  */
    F64 quatErrQ2;                                                   /**< Control error quaternion vector Q2  */
    F32 rwl0CmdSpeed;                                                /**< RWL0 speed command  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl1CmdSpeed;                                                /**< RWL1 speed command  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl2CmdSpeed;                                                /**< RWL2 speed command  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl3CmdSpeed;                                                /**< RWL3 speed command  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl0CmdMom;                                                  /**< RWL0 momentum command  (measurment unit is [N.m.s]. valid range is between -10 N.m.s and 10 N.m.s) */
    F32 rwl1CmdMom;                                                  /**< RWL1 momentum command  (measurment unit is [N.m.s]. valid range is between -10 N.m.s and 10 N.m.s) */
    F32 rwl2CmdMom;                                                  /**< RWL2 momentum command  (measurment unit is [N.m.s]. valid range is between -10 N.m.s and 10 N.m.s) */
    F32 rwl3CmdMom;                                                  /**< RWL3 momentum command  (measurment unit is [N.m.s]. valid range is between -10 N.m.s and 10 N.m.s) */
    F32 rwl0CmdTorque;                                               /**< RWL0 torque command  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F32 rwl1CmdTorque;                                               /**< RWL1 torque command  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F32 rwl2CmdTorque;                                               /**< RWL2 torque command  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F32 rwl3CmdTorque;                                               /**< RWL3 torque command  (measurment unit is [N.m]. valid range is between -1 N.m and 1 N.m) */
    F64 mtq0CmdDip;                                                  /**< MTQ0 dipole moment command  (measurment unit is [A.m^2]) */
    F64 mtq1CmdDip;                                                  /**< MTQ1 dipole moment command  (measurment unit is [A.m^2]) */
    F64 mtq2CmdDip;                                                  /**< MTQ2 dipole moment command  (measurment unit is [A.m^2]) */
    F32 mtq0CmdTorque;                                               /**< MTQ0 torque command  (measurment unit is [N.m]. valid range is between -0.001 N.m and 0.001 N.m) */
    F32 mtq1CmdTorque;                                               /**< MTQ1 torque command  (measurment unit is [N.m]. valid range is between -0.001 N.m and 0.001 N.m) */
    F32 mtq2CmdTorque;                                               /**< MTQ2 torque command  (measurment unit is [N.m]. valid range is between -0.001 N.m and 0.001 N.m) */
    S16 mtq0CmdOnTime;                                               /**< MTQ0 on-time command  (measurment unit is [ms]) */
    S16 mtq1CmdOnTime;                                               /**< MTQ1 on-time command  (measurment unit is [ms]) */
    S16 mtq2CmdOnTime;                                               /**< MTQ2 on-time command  (measurment unit is [ms]) */
    U16 magConTimeout;                                               /**< Magnetic control timeout  (measurment unit is [s]) */
    TypesCubeComputerControlProgram8_ConModeSelect conModeActive;    /**< Active control mode  */
    Boolean rwl0ErrorFlag;                                           /**< RWL0 error flag  */
    Boolean rwl1ErrorFlag;                                           /**< RWL1 error flag  */
    Boolean rwl2ErrorFlag;                                           /**< RWL2 error flag  */
    Boolean rwl3ErrorFlag;                                           /**< RWL3 error flag  */
    Boolean rwl0ActiveFlag;                                          /**< RWL0 active flag  */
    Boolean rwl1ActiveFlag;                                          /**< RWL1 active flag  */
    Boolean rwl2ActiveFlag;                                          /**< RWL2 active flag  */
    Boolean rwl3ActiveFlag;                                          /**< RWL3 active flag  */
    TypesCubeComputerControlProgram8_FmcStage fmcStage;              /**< Current FMC Stage  */
} TypesCubeComputerControlProgram8_TlmController;

/**
 * @brief ASGP4 Orbital Parameters message structure
 * @details Augmented orbital parameters
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmAsgp4Struct {
    F64 asgp4Epoch;    /**< ASGP4 epoch  (measurment unit is [yyddd.ssssssss]. valid range is between 0 yyddd.ssssssss and 100000 yyddd.ssssssss) */
    F64 asgp4Incl;     /**< ASGP4 inclination  (measurment unit is [deg]. valid range is between 0 deg and 180 deg) */
    F64 asgp4Raan;     /**< ASGP4 RAAN  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 asgp4Eccen;    /**< ASGP4 eccentricity  (valid range is between 0  and 1 ) */
    F64 asgp4AP;       /**< ASGP4 argument of perigee  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 asgp4MA;       /**< ASGP4 mean anomaly  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 asgp4MM;       /**< ASGP4 mean motion  (measurment unit is [orbits/day]. valid range is between 0 orbits/day and 20 orbits/day) */
    F64 asgp4Bstar;    /**< ASGP4 B-star drag term  (valid range is between 0  and 1 ) */
} TypesCubeComputerControlProgram8_TlmAsgp4;

/**
 * @brief HIL telemetry message structure
 * @details HIL telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmHilStruct {
    TypesCubeComputerControlProgram8_ConModeSelect conModeActive;    /**< Active control mode  (measurment unit is [degps]) */
    TypesCubeComputerControlProgram8_EstModeSelect estModeActive;    /**< Active estimator mode  */
    TypesCubeComputerControlProgram8_OrbModeSelect orbModeActive;    /**< Active orbit mode  */
    TypesCubeComputerControlProgram8_NavSource navSource;            /**< Source of current orbit position and velocity  */
    Boolean asgp4Error;                                              /**< GNSS and ASGP4 position error differs too much  */
    Boolean hilSyncOk;                                               /**< HIL is currently synchronised  */
    F32 rwl0CmdSpeed;                                                /**< RWL0 speed command  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl1CmdSpeed;                                                /**< RWL1 speed command  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl2CmdSpeed;                                                /**< RWL2 speed command  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl3CmdSpeed;                                                /**< RWL3 speed command  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    S16 mtq0CmdOnTime;                                               /**< MTQ0 on-time command  (measurment unit is [ms]) */
    S16 mtq1CmdOnTime;                                               /**< MTQ1 on-time command  (measurment unit is [ms]) */
    S16 mtq2CmdOnTime;                                               /**< MTQ2 on-time command  (measurment unit is [ms]) */
    U16 magConTimeout;                                               /**< Magnetic control timeout  (measurment unit is [s]) */
    Boolean rwl0ErrorFlag;                                           /**< RWL0 error flag  (measurment unit is [degps]) */
    Boolean rwl1ErrorFlag;                                           /**< RWL1 error flag  (measurment unit is [degps]) */
    Boolean rwl2ErrorFlag;                                           /**< RWL2 error flag  (measurment unit is [degps]) */
    Boolean rwl3ErrorFlag;                                           /**< RWL3 error flag  (measurment unit is [degps]) */
    Boolean rwl0ActiveFlag;                                          /**< RWL0 active flag  (measurment unit is [degps]) */
    Boolean rwl1ActiveFlag;                                          /**< RWL1 active flag  (measurment unit is [degps]) */
    Boolean rwl2ActiveFlag;                                          /**< RWL2 active flag  (measurment unit is [degps]) */
    Boolean rwl3ActiveFlag;                                          /**< RWL3 active flag  (measurment unit is [degps]) */
    F32 estQuatQ0;                                                   /**< Estimated ORC quaternion Q0  (valid range is between -1  and 1 ) */
    F32 estQuatQ1;                                                   /**< Estimated ORC quaternion Q1  (valid range is between -1  and 1 ) */
    F32 estQuatQ2;                                                   /**< Estimated ORC quaternion Q2  (valid range is between -1  and 1 ) */
    F32 estQuatQ3;                                                   /**< Estimated ORC quaternion Q3  (valid range is between -1  and 1 ) */
    F32 estRateOrcX;                                                 /**< Estimated body rate (ORC) X component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 estRateOrcY;                                                 /**< Estimated body rate (ORC) Y component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 estRateOrcZ;                                                 /**< Estimated body rate (ORC) Z component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    S32 satPosEciX;                                                  /**< Satellite ECI position vector X component  (measurment unit is [m]) */
    S32 satPosEciY;                                                  /**< Satellite ECI position vector Y component  (measurment unit is [m]) */
    S32 satPosEciZ;                                                  /**< Satellite ECI position vector Z component  (measurment unit is [m]) */
    S16 satVelEciX;                                                  /**< Satellite ECI velocity vector X component  (measurment unit is [m/s]) */
    S16 satVelEciY;                                                  /**< Satellite ECI velocity vector Y component  (measurment unit is [m/s]) */
    S16 satVelEciZ;                                                  /**< Satellite ECI velocity vector Z component  (measurment unit is [m/s]) */
    F32 rpyCmdRoll;                                                  /**< Commanded roll angle  (measurment unit is [deg]. valid range is between -180 deg and 180 deg) */
    F32 rpyCmdPitch;                                                 /**< Commanded pitch angle  (measurment unit is [deg]. valid range is between -180 deg and 180 deg) */
    F32 rpyCmdYaw;                                                   /**< Commanded yaw angle  (measurment unit is [deg]. valid range is between -180 deg and 180 deg) */
    U16 asgp4BatchCtr;                                               /**< ASGP4 batch counter  */
    U16 asgp4PosDelta;                                               /**< Average position error between GNSS and ASGP4  (measurment unit is [m]) */
    F32 rwl0MeasSpeed;                                               /**< RWL0 speed measurement  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl1MeasSpeed;                                               /**< RWL1 speed measurement  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl2MeasSpeed;                                               /**< RWL2 speed measurement  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl3MeasSpeed;                                               /**< RWL3 speed measurement  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    Boolean rwl0MeasValid;                                           /**< RWL0 measurement valid flag  */
    Boolean rwl1MeasValid;                                           /**< RWL1 measurement valid flag  */
    Boolean rwl2MeasValid;                                           /**< RWL2 measurement valid flag  */
    Boolean rwl3MeasValid;                                           /**< RWL3 measurement valid flag  */
    TypesCubeComputerControlProgram8_FmcStage fmcStage;              /**< Current FMC Stage  */
} TypesCubeComputerControlProgram8_TlmHil;

/**
 * @brief ACP execution telemetry message structure
 * @details ACP execution telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmAcpExecutionStruct {
    U16 timeSinceLoopStart;                                                      /**< Time since the start of the current loop iteration  (measurment unit is [ms]) */
    TypesCubeComputerControlProgram8_AcpExecutionPoint currentExecutionPoint;    /**< Indicates which part of the loop is currently executing  */
    U16 execTimeNodeSync;                                                        /**< Execution time of node sync  (measurment unit is [ms]) */
    U16 execTimeSensorComms;                                                     /**< Execution time of sensor comms  (measurment unit is [ms]) */
    U16 execTimeSensorCal;                                                       /**< Execution time of sensor calibration  (measurment unit is [ms]) */
    U16 execTimeEstimators;                                                      /**< Execution time of ADCS estimators  (measurment unit is [ms]) */
    U16 execTimeControllers;                                                     /**< Execution time of ADCS controllers  (measurment unit is [ms]) */
    U16 execTimeWheelComms;                                                      /**< Execution time of wheel comms  (measurment unit is [ms]) */
    U16 execTimeModels;                                                          /**< Execution time of ADCS models  (measurment unit is [ms]) */
    U16 execTimeLoopSync;                                                        /**< Execution time of ADCS loop sync  (measurment unit is [ms]) */
    U16 execTimeHealth;                                                          /**< Execution time of health service  (measurment unit is [ms]) */
    U16 execTimeTlmLog;                                                          /**< Execution time of telemetry logging  (measurment unit is [ms]) */
    S16 loopRtcOffset;                                                           /**< Time offset between the ADCS loop and RTC control pulse  (measurment unit is [ms]) */
    Boolean loopHasStarted;                                                      /**< ADCS loop has started flag  */
    Boolean hilSyncOk;                                                           /**< HIL is currently synchronised  */
} TypesCubeComputerControlProgram8_TlmAcpExecution;

/**
 * @brief Current execution point message structure
 * @details Current execution point
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmExecutionPointStruct {
    TypesCubeComputerControlProgram8_AcpExecutionPoint currentExecutionPoint;    /**< Indicates which part of the loop is currently executing  */
} TypesCubeComputerControlProgram8_TlmExecutionPoint;

/**
 * @brief Torquer Current measurements message structure
 * @details Current measurements
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmTorquerCurrentsStruct {
    F32 mtq1TotalCurrentPeakPos;                                  /**< Total magnetorquer 1 positive current peak (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    F32 mtq1TotalCurrentAveragePos;                               /**< Total magnetorquer 1 positive current average (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    F32 mtq1TotalCurrentPeakNeg;                                  /**< Total magnetorquer 1 negative current peak (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    F32 mtq1TotalCurrentAverageNeg;                               /**< Total magnetorquer 1 negative current average (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    F32 mtq2TotalCurrentPeakPos;                                  /**< Total magnetorquer 2 positive current peak (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    F32 mtq2TotalCurrentAveragePos;                               /**< Total magnetorquer 2 positive current average (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    F32 mtq2TotalCurrentPeakNeg;                                  /**< Total magnetorquer 2 negative current peak (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    F32 mtq2TotalCurrentAverageNeg;                               /**< Total magnetorquer 2 negative current average (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    F32 mtq3TotalCurrentPeakPos;                                  /**< Total magnetorquer 3 positive current peak (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    F32 mtq3TotalCurrentAveragePos;                               /**< Total magnetorquer 3 positive current average (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    F32 mtq3TotalCurrentPeakNeg;                                  /**< Total magnetorquer 3 negative current peak (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    F32 mtq3TotalCurrentAverageNeg;                               /**< Total magnetorquer 3 negative current average (mA)  (measurment unit is [mA]. valid range is between -500 mA and 500 mA) */
    TypesCubeComputerControlProgram8_MtqPolarity mtq1Polarity;    /**< The polarity of magnetorquer 1 on the last iteration  */
    TypesCubeComputerControlProgram8_MtqPolarity mtq2Polarity;    /**< The polarity of magnetorquer 2 on the last iteration  */
    TypesCubeComputerControlProgram8_MtqPolarity mtq3Polarity;    /**< The polarity of magnetorquer 3 on the last iteration  */
} TypesCubeComputerControlProgram8_TlmTorquerCurrents;

/**
 * @brief CubeComputer Health message structure
 * @details Health telemetry for ADCS CubeComputer
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmCubeComputerHealthStruct {
    F64 mcuTemp;                    /**< MCU Temperature  (measurment unit is [C]) */
    F64 mcuCurrent;                 /**< MCU current  (measurment unit is [mA]) */
    U16 mcuVoltage;                 /**< MCU internal reference voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    U16 supplyVoltage;              /**< MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    U16 v5Sense;                    /**< 5V supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    U16 batteryVoltage;             /**< Battery voltage  (measurment unit is [mV]. valid range is between 0 mV and 33000 mV) */
    U16 versionVoltage;             /**< Hardware Version voltage  (measurment unit is [mV]. valid range is between 0 mV and 3300 mV) */
    F64 sram1Current;               /**< SRAM1 current  (measurment unit is [mA]) */
    F64 sram2Current;               /**< SRAM2 current  (measurment unit is [mA]) */
    F64 fpgaCurrent1v5;             /**< FPGA current on 1v5 rail  (measurment unit is [mA]) */
    F64 framCurrent;                /**< FRAM current  (measurment unit is [mA]) */
    F64 adcCurrent;                 /**< ADC current  (measurment unit is [mA]) */
    F64 flashCurrent;               /**< Flash memory current  (measurment unit is [mA]) */
    F64 rs485Current;               /**< RS485 driver current  (measurment unit is [mA]) */
    F64 canCurrent;                 /**< CAN driver current  (measurment unit is [mA]) */
    F64 gyroCurrent;                /**< Gyro current  (measurment unit is [mA]) */
    F64 redGyroCurrent;             /**< Redundant gyro current  (measurment unit is [mA]) */
    Boolean gyroOverVoltage;        /**< Set if the primary gyro supply voltage has exceeded the maximum limit  */
    Boolean gyroUnderVoltage;       /**< Set if the primary gyro supply voltage has exceeded the minimum limit  */
    Boolean redGyroOverVoltage;     /**< Set if the redundant gyro supply voltage has exceeded the maximum limit  */
    Boolean redGyroUnderVoltage;    /**< Set if the redundant gyro supply voltage has exceeded the minimum limit  */
    U8 watchdogCount[5];            /**< Bitmask representing virtual watchdog region warning counters.  */
} TypesCubeComputerControlProgram8_TlmCubeComputerHealth;

/**
 * @brief Health telemetry for CubeSense Sun message structure
 * @details Health telemetry for CubeSense Sun
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmFssCubeSenseSunHealthStruct {
    F64 fss0McuTemp;                /**< FSS0 MCU Temperature  (measurment unit is [C]) */
    F64 fss0McuCurrent;             /**< FSS0 MCU current  (measurment unit is [mA]) */
    U16 fss0McuVoltage;             /**< FSS0 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 fss0CurrentCam;             /**< FSS0 Camera current  (measurment unit is [mA]) */
    F64 fss0CurrentSram;            /**< FSS0 SRAM current  (measurment unit is [mA]) */
    Boolean fss0OvercurrentCam;     /**< FSS0 CAM overcurrent detected  */
    Boolean fss0OvercurrentSram;    /**< FSS0 SRAM overcurrent detected  */
    F64 fss1McuTemp;                /**< FSS1 MCU Temperature  (measurment unit is [C]) */
    F64 fss1McuCurrent;             /**< FSS1 MCU current  (measurment unit is [mA]) */
    U16 fss1McuVoltage;             /**< FSS1 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 fss1CurrentCam;             /**< FSS1 Camera current  (measurment unit is [mA]) */
    F64 fss1CurrentSram;            /**< FSS1 SRAM current  (measurment unit is [mA]) */
    Boolean fss1OvercurrentCam;     /**< FSS1 CAM overcurrent detected  */
    Boolean fss1OvercurrentSram;    /**< FSS1 SRAM overcurrent detected  */
    F64 fss2McuTemp;                /**< FSS2 MCU Temperature  (measurment unit is [C]) */
    F64 fss2McuCurrent;             /**< FSS2 MCU current  (measurment unit is [mA]) */
    U16 fss2McuVoltage;             /**< FSS2 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 fss2CurrentCam;             /**< FSS2 Camera current  (measurment unit is [mA]) */
    F64 fss2CurrentSram;            /**< FSS2 SRAM current  (measurment unit is [mA]) */
    Boolean fss2OvercurrentCam;     /**< FSS2 CAM overcurrent detected  */
    Boolean fss2OvercurrentSram;    /**< FSS2 SRAM overcurrent detected  */
    F64 fss3McuTemp;                /**< FSS3 MCU Temperature  (measurment unit is [C]) */
    F64 fss3McuCurrent;             /**< FSS3 MCU current  (measurment unit is [mA]) */
    U16 fss3McuVoltage;             /**< FSS3 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 fss3CurrentCam;             /**< FSS3 Camera current  (measurment unit is [mA]) */
    F64 fss3CurrentSram;            /**< FSS3 SRAM current  (measurment unit is [mA]) */
    Boolean fss3OvercurrentCam;     /**< FSS3 CAM overcurrent detected  */
    Boolean fss3OvercurrentSram;    /**< FSS3 SRAM overcurrent detected  */
} TypesCubeComputerControlProgram8_TlmFssCubeSenseSunHealth;

/**
 * @brief Health telemetry for CubeSense Earth message structure
 * @details Health telemetry for CubeSense Earth
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmHssCubeSenseEarthHealthStruct {
    F64 hss0McuTemp;            /**< HSS0 MCU Temperature  (measurment unit is [C]) */
    F64 hss0McuCurrent;         /**< HSS0 MCU current  (measurment unit is [mA]) */
    U16 hss0McuVoltage;         /**< HSS0 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 hss0DetectorTemp;       /**< HSS0 Detector Temperature  (measurment unit is [dK]) */
    F64 hss0DetectorCurrent;    /**< HSS0 Detector Current  (measurment unit is [mA]) */
    F64 hss1McuTemp;            /**< HSS1 MCU Temperature  (measurment unit is [C]) */
    F64 hss1McuCurrent;         /**< HSS1 MCU current  (measurment unit is [mA]) */
    U16 hss1McuVoltage;         /**< HSS1 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 hss1DetectorTemp;       /**< HSS1 Detector Temperature  (measurment unit is [dK]) */
    F64 hss1DetectorCurrent;    /**< HSS1 Detector Current  (measurment unit is [mA]) */
} TypesCubeComputerControlProgram8_TlmHssCubeSenseEarthHealth;

/**
 * @brief Health telemetry for CubeMag magnetometer message structure
 * @details Health telemetry for CubeMag magnetometer
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmCubeMagHealthStruct {
    F64 mag0McuTemp;                 /**< MAG0 MCU Temperature  (measurment unit is [C]) */
    F64 mag0McuCurrent;              /**< MAG0 MCU current  (measurment unit is [mA]) */
    U16 mag0McuVoltage;              /**< MAG0 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 mag0PrimaryTemp;             /**< MAG0 Detector Temperature  (measurment unit is [C]) */
    F64 mag0RedTemp;                 /**< MAG0 Detector Current  (measurment unit is [C]) */
    U32 mag0BurnCurrent;             /**< MAG0 Deploy Burn Current  (measurment unit is [mA]) */
    Boolean mag0DeployPinState;      /**< MAG0 Deploy Pin State  */
    Boolean mag0BurnPinState;        /**< MAG0 Burn Pin State  */
    Boolean mag0BurnUnderCurrent;    /**< MAG0 Burn Under Current Flag  */
    Boolean mag0BurnOverCurrent;     /**< MAG0 Burn Over Current Flag  */
    Boolean mag0DeployTimeout;       /**< MAG0 Deployment timeout Flag  */
    F64 mag1McuTemp;                 /**< MAG1 MCU Temperature  (measurment unit is [C]) */
    F64 mag1McuCurrent;              /**< MAG1 MCU current  (measurment unit is [mA]) */
    U16 mag1McuVoltage;              /**< MAG1 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 mag1PrimaryTemp;             /**< MAG1 Detector Temperature  (measurment unit is [C]) */
    F64 mag1RedTemp;                 /**< MAG1 Detector Current  (measurment unit is [C]) */
    U32 mag1BurnCurrent;             /**< MAG1 Deploy Burn Current  (measurment unit is [mA]) */
    Boolean mag1DeployPinState;      /**< MAG1 Deploy Pin State  */
    Boolean mag1BurnPinState;        /**< MAG1 Burn Pin State  */
    Boolean mag1BurnUnderCurrent;    /**< MAG1 Burn Under Current Flag  */
    Boolean mag1BurnOverCurrent;     /**< MAG1 Burn Over Current Flag  */
    Boolean mag1DeployTimeout;       /**< MAG1 Deployment timeout Flag  */
} TypesCubeComputerControlProgram8_TlmCubeMagHealth;

/**
 * @brief Health telemetry for Reaction Wheels message structure
 * @details Health telemetry for reaction wheels
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmRwlHealthStruct {
    F64 rwl0McuTemp;       /**< RWL0 MCU Temperature  (measurment unit is [C]) */
    F64 rwl0McuCurrent;    /**< RWL0 MCU current  (measurment unit is [mA]) */
    U16 rwl0BatVoltage;    /**< RWL0 Battery supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 36000 mV) */
    F64 rwl0BatCurrent;    /**< RWL0 Battery current  (measurment unit is [mA]) */
    F64 rwl1McuTemp;       /**< RWL1 MCU Temperature  (measurment unit is [C]) */
    F64 rwl1McuCurrent;    /**< RWL1 MCU current  (measurment unit is [mA]) */
    U16 rwl1BatVoltage;    /**< RWL1 Battery supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 36000 mV) */
    F64 rwl1BatCurrent;    /**< RWL1 Battery current  (measurment unit is [mA]) */
    F64 rwl2McuTemp;       /**< RWL2 MCU Temperature  (measurment unit is [C]) */
    F64 rwl2McuCurrent;    /**< RWL2 MCU current  (measurment unit is [mA]) */
    U16 rwl2BatVoltage;    /**< RWL2 Battery supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 36000 mV) */
    F64 rwl2BatCurrent;    /**< RWL2 Battery current  (measurment unit is [mA]) */
    F64 rwl3McuTemp;       /**< RWL3 MCU Temperature  (measurment unit is [C]) */
    F64 rwl3McuCurrent;    /**< RWL3 MCU current  (measurment unit is [mA]) */
    U16 rwl3BatVoltage;    /**< RWL3 Battery supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 36000 mV) */
    F64 rwl3BatCurrent;    /**< RWL3 Battery current  (measurment unit is [mA]) */
} TypesCubeComputerControlProgram8_TlmRwlHealth;

/**
 * @brief Health telemetry for CubeNode PST3S message structure
 * @details Health telemetry for CubeNode PST3S
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmStrPst3sHealthStruct {
    F64 str0McuTemp;                 /**< STR0 MCU Temperature  (measurment unit is [C]) */
    F64 str0McuCurrent;              /**< STR0 MCU current  (measurment unit is [mA]) */
    U16 str0McuVoltage;              /**< STR0 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 str0Pst3sCurrent;            /**< STR0 PST3S current  (measurment unit is [mA]) */
    Boolean str0Pst3sOvercurrent;    /**< STR0 PST3S CAM overcurrent  */
    F64 str1McuTemp;                 /**< STR1 MCU Temperature  (measurment unit is [C]) */
    F64 str1McuCurrent;              /**< STR1 MCU current  (measurment unit is [mA]) */
    U16 str1McuVoltage;              /**< STR1 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 str1Pst3sCurrent;            /**< STR1 PST3S current  (measurment unit is [mA]) */
    Boolean str1Pst3sOvercurrent;    /**< STR1 PST3S CAM overcurrent  */
} TypesCubeComputerControlProgram8_TlmStrPst3sHealth;

/**
 * @brief Health telemetry for CubeStar message structure
 * @details Health telemetry for CubeStar star camera
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmStrHealthStruct {
    F64 str0McuTemp;               /**< STR0 MCU Temperature  (measurment unit is [C]) */
    F64 str0McuCurrent;            /**< STR0 MCU current  (measurment unit is [mA]) */
    U16 str0McuVoltage;            /**< STR0 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 str0Current;               /**< STR0 current  (measurment unit is [mA]) */
    F64 str0CurrentPk;             /**< STR0 peak current  (measurment unit is [mA]) */
    F64 str0DetectorPcbTemp;       /**< STR0 detector PCB temperature  (measurment unit is [C]) */
    Boolean str0SensorInitOk;      /**< STR0 sensor initialised without error  */
    Boolean str0SensorConfigOk;    /**< STR0 sensor configured without error  */
    U32 str0ErrorCode;             /**< STR0 Error Code  */
    F64 str1McuTemp;               /**< STR1 MCU Temperature  (measurment unit is [C]) */
    F64 str1McuCurrent;            /**< STR1 MCU current  (measurment unit is [mA]) */
    U16 str1McuVoltage;            /**< STR1 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 str1Current;               /**< STR1 current  (measurment unit is [mA]) */
    F64 str1CurrentPk;             /**< STR1 peak current  (measurment unit is [mA]) */
    F64 str1DetectorPcbTemp;       /**< STR1 detector PCB temperature  (measurment unit is [C]) */
    Boolean str1SensorInitOk;      /**< STR1 sensor initialised without error  */
    Boolean str1SensorConfigOk;    /**< STR1 sensor configured without error  */
    U32 str1ErrorCode;             /**< STR1 Error Code  */
} TypesCubeComputerControlProgram8_TlmStrHealth;

/**
 * @brief Health telemetry for CubeAuriga message structure
 * @details Health telemetry for CubeAuriga star camera
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmStrAurigaHealthStruct {
    U16 str0McuVoltage;                                                /**< MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    S16 str0McuTemp;                                                   /**< MCU Temperature  (measurment unit is [C]. valid range is between -40 C and 120 C) */
    F64 str0McuCurrent;                                                /**< MCU current  (measurment unit is [mA]. valid range is between 0 mA and 150 mA) */
    F64 str0SramCurrent;                                               /**< SRAM current  (measurment unit is [mA]. valid range is between 0 mA and 100 mA) */
    F64 str0Oh1Current;                                                /**< OH1 Current  (measurment unit is [mA]. valid range is between 0 mA and 300 mA) */
    F64 str0Oh2Current;                                                /**< OH2 Current  (measurment unit is [mA]. valid range is between 0 mA and 300 mA) */
    F64 str0Fpga1Current;                                              /**< FPGA1 Current  (measurment unit is [mA]. valid range is between 0 mA and 200 mA) */
    F64 str0Fpga2Current;                                              /**< FPGA2 Current  (measurment unit is [mA]. valid range is between 0 mA and 200 mA) */
    U16 str0Fpga1Voltage;                                              /**< FPGA1 Voltage  (measurment unit is [mA]. valid range is between 0 mA and 5000 mA) */
    U16 str0Fpga2Voltage;                                              /**< FPGA2 Voltage  (measurment unit is [mA]. valid range is between 0 mA and 5000 mA) */
    U16 str0ProcessIdleTiming;                                         /**< Process idle delay (idle time between consecutive processing cycles)  (measurment unit is [ms]) */
    U16 str0AcqSynthFlags;                                             /**< STR Synthesis flags for analog acquisition  */
    TypesCubeComputerControlProgram8_AurigaLibStateVal str0STRMode;    /**< Star Tracker Mode  */
    S16 str0OH1Temp;                                                   /**< OH1 Temperature  */
    S16 str0OH2Temp;                                                   /**< OH2 Temperature  */
    U16 str0BlocksValidity;                                            /**< Blocks Validity at library initialization  */
    U8 str0ResetCnt;                                                   /**< STR hot reset counters  */
    U8 str0LastTCSeqNum;                                               /**< Sequence number (8 low bits) of the last STR TC processed  */
    U8 str0TCCnt;                                                      /**< STR TC counters  */
    U8 str0ErrorInfo;                                                  /**< Number of errors since last STR cold reset and various error indicator  */
    U32 str0LastErrorParam;                                            /**< Last Error Parameter  */
    U8 str0LastErrorId;                                                /**< Last Error Identifier  */
    U8 str0TRKLossCnt;                                                 /**< Number of loss of tracking since last STR reset  */
    U16 str1McuVoltage;                                                /**< MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    S16 str1McuTemp;                                                   /**< MCU Temperature  (measurment unit is [C]. valid range is between -40 C and 120 C) */
    F64 str1McuCurrent;                                                /**< MCU current  (measurment unit is [mA]. valid range is between 0 mA and 150 mA) */
    F64 str1SramCurrent;                                               /**< SRAM current  (measurment unit is [mA]. valid range is between 0 mA and 100 mA) */
    F64 str1Oh1Current;                                                /**< OH1 Current  (measurment unit is [mA]. valid range is between 0 mA and 300 mA) */
    F64 str1Oh2Current;                                                /**< OH2 Current  (measurment unit is [mA]. valid range is between 0 mA and 300 mA) */
    F64 str1Fpga1Current;                                              /**< FPGA1 Current  (measurment unit is [mA]. valid range is between 0 mA and 200 mA) */
    F64 str1Fpga2Current;                                              /**< FPGA2 Current  (measurment unit is [mA]. valid range is between 0 mA and 200 mA) */
    U16 str1Fpga1Voltage;                                              /**< FPGA1 Voltage  (measurment unit is [mA]. valid range is between 0 mA and 5000 mA) */
    U16 str1Fpga2Voltage;                                              /**< FPGA2 Voltage  (measurment unit is [mA]. valid range is between 0 mA and 5000 mA) */
    U16 str1ProcessIdleTiming;                                         /**< Process idle delay (idle time between consecutive processing cycles)  (measurment unit is [ms]) */
    U16 str1AcqSynthFlags;                                             /**< STR Synthesis flags for analog acquisition  */
    TypesCubeComputerControlProgram8_AurigaLibStateVal str1STRMode;    /**< Star Tracker Mode  */
    S16 str1OH1Temp;                                                   /**< OH1 Temperature  */
    S16 str1OH2Temp;                                                   /**< OH2 Temperature  */
    U16 str1BlocksValidity;                                            /**< Blocks Validity at library initialization  */
    U8 str1ResetCnt;                                                   /**< STR hot reset counters  */
    U8 str1LastTCSeqNum;                                               /**< Sequence number (8 low bits) of the last STR TC processed  */
    U8 str1TCCnt;                                                      /**< STR TC counters  */
    U8 str1ErrorInfo;                                                  /**< Number of errors since last STR cold reset and various error indicator  */
    U32 str1LastErrorParam;                                            /**< Last Error Parameter  */
    U8 str1LastErrorId;                                                /**< Last Error Identifier  */
    U8 str1TRKLossCnt;                                                 /**< Number of loss of tracking since last STR reset  */
} TypesCubeComputerControlProgram8_TlmStrAurigaHealth;

/**
 * @brief Health telemetry for CubeNode NSSRWL message structure
 * @details Health telemetry for CubeNode NSSRWL
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmNssRwlHealthStruct {
    F64 rwl0McuTemp;                /**< RWL0 MCU Temperature  (measurment unit is [C]) */
    F64 rwl0McuCurrent;             /**< RWL0 MCU current  (measurment unit is [mA]) */
    U16 rwl0McuVoltage;             /**< RWL0 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 rwl0Current5v;              /**< RWL0 5V current  (measurment unit is [mA]) */
    U16 rwl0PmuCurrent;             /**< RWL0 PMU Current  (measurment unit is [mA]) */
    Boolean rwl0Overcurrent5v;      /**< RWL0 5V overcurrent  */
    Boolean rwl0PowerGood;          /**< RWL0 PowerGood signal  */
    Boolean rwl0PmuCurrentValid;    /**< RWL0 Set if measurement was successful  */
    F64 rwl1McuTemp;                /**< RWL1 MCU Temperature  (measurment unit is [C]) */
    F64 rwl1McuCurrent;             /**< RWL1 MCU current  (measurment unit is [mA]) */
    U16 rwl1McuVoltage;             /**< RWL1 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 rwl1Current5v;              /**< RWL1 5V current  (measurment unit is [mA]) */
    U16 rwl1PmuCurrent;             /**< RWL1 PMU Current  (measurment unit is [mA]) */
    Boolean rwl1Overcurrent5v;      /**< Rwl1 5V overcurrent  */
    Boolean rwl1PowerGood;          /**< Rwl1 PowerGood signal  */
    Boolean rwl1PmuCurrentValid;    /**< RWL1 Set if measurement was successful  */
    F64 rwl2McuTemp;                /**< RWL2 MCU Temperature  (measurment unit is [C]) */
    F64 rwl2McuCurrent;             /**< RWL2 MCU current  (measurment unit is [mA]) */
    U16 rwl2McuVoltage;             /**< RWL2 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 rwl2Current5v;              /**< RWL2 5V current  (measurment unit is [mA]) */
    U16 rwl2PmuCurrent;             /**< RWL2 PMU Current  (measurment unit is [mA]) */
    Boolean rwl2Overcurrent5v;      /**< Rwl2 5V overcurrent  */
    Boolean rwl2PowerGood;          /**< Rwl2 PowerGood signal  */
    Boolean rwl2PmuCurrentValid;    /**< RWL2 Set if measurement was successful  */
    F64 rwl3McuTemp;                /**< RWL3 MCU Temperature  (measurment unit is [C]) */
    F64 rwl3McuCurrent;             /**< RWL3 MCU current  (measurment unit is [mA]) */
    U16 rwl3McuVoltage;             /**< RWL3 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 rwl3Current5v;              /**< RWL3 5V current  (measurment unit is [mA]) */
    U16 rwl3PmuCurrent;             /**< RWL3 PMU Current  (measurment unit is [mA]) */
    Boolean rwl3Overcurrent5v;      /**< Rwl3 5V overcurrent  */
    Boolean rwl3PowerGood;          /**< Rwl3 PowerGood signal  */
    Boolean rwl3PmuCurrentValid;    /**< RWL3 Set if measurement was successful  */
} TypesCubeComputerControlProgram8_TlmNssRwlHealth;

/**
 * @brief Health telemetry for CubeNode LITEFUFORS message structure
 * @details Health telemetry for CubeNode LITEFUFORS
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmLitefuforsHealthStruct {
    F64 gyr0McuTemp;             /**< EXTGYR0 MCU Temperature  (measurment unit is [C]) */
    F64 gyr0McuCurrent;          /**< EXTGYR0 MCU current  (measurment unit is [mA]) */
    U16 gyr0McuVoltage;          /**< EXTGYR0 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 gyr0Current1;            /**< EXTGYR0 axis-1 current  (measurment unit is [mA]) */
    F64 gyr0Current2;            /**< EXTGYR0 axis-2 current  (measurment unit is [mA]) */
    F64 gyr0Current3;            /**< EXTGYR0 axis-3 current  (measurment unit is [mA]) */
    Boolean gyr0Overcurrent1;    /**< EXTGYR0 axis-1 overcurrent  */
    Boolean gyr0Overcurrent2;    /**< EXTGYR0 axis-2 overcurrent  */
    Boolean gyr0Overcurrent3;    /**< EXTGYR0 axis-3 overcurrent  */
    F64 gyr1McuTemp;             /**< EXTGYR1 MCU Temperature  (measurment unit is [C]) */
    F64 gyr1McuCurrent;          /**< EXTGYR1 MCU current  (measurment unit is [mA]) */
    U16 gyr1McuVoltage;          /**< EXTGYR1 MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    F64 gyr1Current1;            /**< EXTGYR1 axis-1 current  (measurment unit is [mA]) */
    F64 gyr1Current2;            /**< EXTGYR1 axis-2 current  (measurment unit is [mA]) */
    F64 gyr1Current3;            /**< EXTGYR1 axis-3 current  (measurment unit is [mA]) */
    Boolean gyr1Overcurrent1;    /**< EXTGYR1 axis-1 overcurrent  */
    Boolean gyr1Overcurrent2;    /**< EXTGYR1 axis-2 overcurrent  */
    Boolean gyr1Overcurrent3;    /**< EXTGYR1 axis-3 overcurrent  */
} TypesCubeComputerControlProgram8_TlmLitefuforsHealth;

/**
 * @brief Node Initialization States message structure
 * @details Current initialization state of each node
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmNodeInitStateStruct {
    TypesCubeComputerControlProgram8_InitState rwl0State;          /**< RWL0 init state  */
    TypesCubeComputerControlProgram8_InitState rwl1State;          /**< RWL1 init state  */
    TypesCubeComputerControlProgram8_InitState rwl2State;          /**< RWL2 init state  */
    TypesCubeComputerControlProgram8_InitState rwl3State;          /**< RWL3 init state  */
    TypesCubeComputerControlProgram8_InitState mag0State;          /**< MAG0 init state  */
    TypesCubeComputerControlProgram8_InitState mag1State;          /**< MAG1 init state  */
    TypesCubeComputerControlProgram8_InitState gyro0State;         /**< GYR0 init state  */
    TypesCubeComputerControlProgram8_InitState gyro1State;         /**< GYR1 init state  */
    TypesCubeComputerControlProgram8_InitState fss0State;          /**< FSS0 init state  */
    TypesCubeComputerControlProgram8_InitState fss1State;          /**< FSS1 init state  */
    TypesCubeComputerControlProgram8_InitState fss2State;          /**< FSS2 init state  */
    TypesCubeComputerControlProgram8_InitState fss3State;          /**< FSS3 init state  */
    TypesCubeComputerControlProgram8_InitState hss0State;          /**< HSS0 init state  */
    TypesCubeComputerControlProgram8_InitState hss1State;          /**< HSS1 init state  */
    TypesCubeComputerControlProgram8_InitState str0State;          /**< STR0 init state  */
    TypesCubeComputerControlProgram8_InitState str1State;          /**< STR1 init state  */
    TypesCubeComputerControlProgram8_InitState extSensor0State;    /**< ExtSensor0 init state  */
    TypesCubeComputerControlProgram8_InitState extSensor1State;    /**< ExtSensor1 init state  */
    TypesCubeComputerControlProgram8_InitState extGyro0State;      /**< EXTGYR0 init state  */
    TypesCubeComputerControlProgram8_InitState extGyro1State;      /**< EXTGYR1 init state  */
} TypesCubeComputerControlProgram8_TlmNodeInitState;

/**
 * @brief GNSS UART Status message structure
 * @details Status telemetry for GNSS UART
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_TlmGnssUartStatusStruct {
    U32 bytesReceived;    /**< Number of bytes received from GNSS UART  */
    U32 errorFlags;       /**< Number of bytes received from GNSS UART  */
} TypesCubeComputerControlProgram8_TlmGnssUartStatus;

/**
 * @brief Control mode message structure
 * @details Control mode
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ConModeStruct {
    TypesCubeComputerControlProgram8_ConModeSelect controlMode;    /**< Control mode  */
    U16 magConTimeout;                                             /**< Magnetic control timeout  (measurment unit is [s]) */
} TypesCubeComputerControlProgram8_ConMode;

/**
 * @brief Estimation mode message structure
 * @details Estimation mode
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_EstModeStruct {
    TypesCubeComputerControlProgram8_EstModeSelect estModeMain;      /**< Main estimator mode  */
    TypesCubeComputerControlProgram8_EstModeSelect estModeBackup;    /**< Backup estimator mode  */
} TypesCubeComputerControlProgram8_EstMode;

/**
 * @brief ADCS run mode message structure
 * @details ADCS run mode
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_AdcsRunModeStruct {
    TypesCubeComputerControlProgram8_AdcsRunModeSelect runMode;    /**< ADCS run mode  */
} TypesCubeComputerControlProgram8_AdcsRunMode;

/**
 * @brief Orbit mode message structure
 * @details Orbit mode
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_OrbModeStruct {
    TypesCubeComputerControlProgram8_OrbModeSelect orbitMode;    /**< Orbit calculation mode  */
} TypesCubeComputerControlProgram8_OrbMode;

/**
 * @brief ADCS operational state message structure
 * @details ADCS operational state
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_AdcsOpStateStruct {
    TypesCubeComputerControlProgram8_AdcsOpStateSelect opState;    /**< ADCS operational state  */
} TypesCubeComputerControlProgram8_AdcsOpState;

/**
 * @brief OpenLoopCommandMtq message structure
 * @details OpenLoopCommandMtq
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_OpenLoopCommandMtqStruct {
    S16 mtq0OnTimeCmd;    /**< MTQ0 open-loop on-time command  (measurment unit is [ms]. valid range is between -1000 ms and 1000 ms) */
    S16 mtq1OnTimeCmd;    /**< MTQ1 open-loop on-time command  (measurment unit is [ms]. valid range is between -1000 ms and 1000 ms) */
    S16 mtq2OnTimeCmd;    /**< MTQ2 open-loop on-time command  (measurment unit is [ms]. valid range is between -1000 ms and 1000 ms) */
} TypesCubeComputerControlProgram8_OpenLoopCommandMtq;

/**
 * @brief OpenLoopCommandRwl message structure
 * @details OpenLoopCommandRwl
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_OpenLoopCommandRwlStruct {
    F32 rwl0SpeedCmd;    /**< RWL0 open-loop speed command  (valid range is between -10000  and 10000 ) */
    F32 rwl1SpeedCmd;    /**< RWL1 open-loop speed command  (valid range is between -10000  and 10000 ) */
    F32 rwl2SpeedCmd;    /**< RWL2 open-loop speed command  (valid range is between -10000  and 10000 ) */
    F32 rwl3SpeedCmd;    /**< RWL3 open-loop speed command  (valid range is between -10000  and 10000 ) */
} TypesCubeComputerControlProgram8_OpenLoopCommandRwl;

/**
 * @brief OpenLoopCommandHxyzRW message structure
 * @details OpenLoopCommandHxyzRW
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_OpenLoopCommandHxyzRWStruct {
    F32 hx;    /**< X-momentum open-loop speed command  (measurment unit is [Nm]. valid range is between -0.1 Nm and 0.1 Nm) */
    F32 hy;    /**< Y-momentum open-loop speed command  (measurment unit is [Nm]. valid range is between -0.1 Nm and 0.1 Nm) */
    F32 hz;    /**< Z-momentum open-loop speed command  (measurment unit is [Nm]. valid range is between -0.1 Nm and 0.1 Nm) */
} TypesCubeComputerControlProgram8_OpenLoopCommandHxyzRW;

/**
 * @brief Commanded GNSS measurements message structure
 * @details GNSS sensor measurements as command to the ADCS
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_GnssSensorCmdStruct {
    U32 gnssTimeSeconds;    /**< GNSS Unix time integer seconds  (measurment unit is [s]) */
    U32 gnssTimeNs;         /**< GNSS Unix time fraction nanoseconds  (measurment unit is [ns]) */
    S32 gnssSatPosX;        /**< Satellite position vector X component (GNSS frame)  (measurment unit is [cm]) */
    S32 gnssSatPosY;        /**< Satellite position vector Y component (GNSS frame)  (measurment unit is [cm]) */
    S32 gnssSatPosZ;        /**< Satellite position vector Z component (GNSS frame)  (measurment unit is [cm]) */
    S32 gnssSatVelX;        /**< Satellite velocity vector X component (GNSS frame)  (measurment unit is [cm/s]) */
    S32 gnssSatVelY;        /**< Satellite velocity vector Y component (GNSS frame)  (measurment unit is [cm/s]) */
    S32 gnssSatVelZ;        /**< Satellite velocity vector Z component (GNSS frame)  (measurment unit is [cm/s]) */
    Boolean syncTime;       /**< Flag to indicate if RTC should sync with unix time  */
} TypesCubeComputerControlProgram8_GnssSensorCmd;

/**
 * @brief Simulation raw sensor telemetry message structure
 * @details Simulation raw sensor telemetry
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_SimSensorRawStruct {
    U32 timeSeconds;              /**< Unix time integer seconds  (measurment unit is [s]) */
    U32 timeNs;                   /**< Unix time fraction nanoseconds  (measurment unit is [ns]) */
    F64 fss0RawCenX;              /**< FSS0 raw centroid X  */
    F64 fss0RawCenY;              /**< FSS0 raw centroid Y  */
    F64 fss1RawCenX;              /**< FSS1 raw centroid X  */
    F64 fss1RawCenY;              /**< FSS1 raw centroid Y  */
    F64 fss2RawCenX;              /**< FSS2 raw centroid X  */
    F64 fss2RawCenY;              /**< FSS2 raw centroid Y  */
    F64 fss3RawCenX;              /**< FSS3 raw centroid X  */
    F64 fss3RawCenY;              /**< FSS3 raw centroid Y  */
    U16 css0Raw;                  /**< CSS0 raw measurement  */
    U16 css1Raw;                  /**< CSS1 raw measurement  */
    U16 css2Raw;                  /**< CSS2 raw measurement  */
    U16 css3Raw;                  /**< CSS3 raw measurement  */
    U16 css4Raw;                  /**< CSS4 raw measurement  */
    U16 css5Raw;                  /**< CSS5 raw measurement  */
    U16 css6Raw;                  /**< CSS6 raw measurement  */
    U16 css7Raw;                  /**< CSS7 raw measurement  */
    U16 css8Raw;                  /**< CSS8 raw measurement  */
    U16 css9Raw;                  /**< CSS9 raw measurement  */
    F64 mag0RawVecX;              /**< MAG0 raw vector X component  (measurment unit is [uT]) */
    F64 mag0RawVecY;              /**< MAG0 raw vector Y component  (measurment unit is [uT]) */
    F64 mag0RawVecZ;              /**< MAG0 raw vector Z component  (measurment unit is [uT]) */
    F64 mag1RawVecX;              /**< MAG1 raw vector X component  (measurment unit is [uT]) */
    F64 mag1RawVecY;              /**< MAG1 raw vector Y component  (measurment unit is [uT]) */
    F64 mag1RawVecZ;              /**< MAG1 raw vector Z component  (measurment unit is [uT]) */
    F32 gyro0RawRateX;            /**< GYR0 raw rate X component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro0RawRateY;            /**< GYR0 raw rate Y component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro0RawRateZ;            /**< GYR0 raw rate Z component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro1RawRateX;            /**< GYR1 raw rate X component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro1RawRateY;            /**< GYR1 raw rate Y component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F32 gyro1RawRateZ;            /**< GYR1 raw rate Z component  (measurment unit is [degps]. valid range is between -1000 degps and 1000 degps) */
    F64 hss0RawElev;              /**< HSS0 raw elevation angle  (measurment unit is [deg]) */
    F64 hss0RawRot;               /**< HSS0 raw rotation angle  (measurment unit is [deg]) */
    F64 hss1RawElev;              /**< HSS1 raw elevation angle  (measurment unit is [deg]) */
    F64 hss1RawRot;               /**< HSS1 raw rotation angle  (measurment unit is [deg]) */
    F64 str0MeasVec0X;            /**< STR0 measured vector 0 X component (sensor frame)  */
    F64 str0MeasVec0Y;            /**< STR0 measured vector 0 Y component (sensor frame)  */
    F64 str0MeasVec0Z;            /**< STR0 measured vector 0 Z component (sensor frame)  */
    F64 str0MeasVec1X;            /**< STR0 measured vector 1 X component (sensor frame)  */
    F64 str0MeasVec1Y;            /**< STR0 measured vector 1 Y component (sensor frame)  */
    F64 str0MeasVec1Z;            /**< STR0 measured vector 1 Z component (sensor frame)  */
    F64 str0MeasVec2X;            /**< STR0 measured vector 2 X component (sensor frame)  */
    F64 str0MeasVec2Y;            /**< STR0 measured vector 2 Y component (sensor frame)  */
    F64 str0MeasVec2Z;            /**< STR0 measured vector 2 Z component (sensor frame)  */
    F64 str0ModelVec0X;           /**< STR0 modelled vector 0 X component (IRC frame)  */
    F64 str0ModelVec0Y;           /**< STR0 modelled vector 0 Y component (IRC frame)  */
    F64 str0ModelVec0Z;           /**< STR0 modelled vector 0 Z component (IRC frame)  */
    F64 str0ModelVec1X;           /**< STR0 modelled vector 1 X component (IRC frame)  */
    F64 str0ModelVec1Y;           /**< STR0 modelled vector 1 Y component (IRC frame)  */
    F64 str0ModelVec1Z;           /**< STR0 modelled vector 1 Z component (IRC frame)  */
    F64 str0ModelVec2X;           /**< STR0 modelled vector 2 X component (IRC frame)  */
    F64 str0ModelVec2Y;           /**< STR0 modelled vector 2 Y component (IRC frame)  */
    F64 str0ModelVec2Z;           /**< STR0 modelled vector 2 Z component (IRC frame)  */
    F64 str0MeasQ0;               /**< STR0 measured quaternion Q0 (sensor to IRC frame)  */
    F64 str0MeasQ1;               /**< STR0 measured quaternion Q1 (sensor to IRC frame)  */
    F64 str0MeasQ2;               /**< STR0 measured quaternion Q2 (sensor to IRC frame)  */
    F64 str0MeasQ3;               /**< STR0 measured quaternion Q3 (sensor to IRC frame)  */
    U8 str0StarIdCount;           /**< STR0 number of identified stars  */
    F64 str1MeasVec0X;            /**< STR1 measured vector 0 X component (sensor frame)  */
    F64 str1MeasVec0Y;            /**< STR1 measured vector 0 Y component (sensor frame)  */
    F64 str1MeasVec0Z;            /**< STR1 measured vector 0 Z component (sensor frame)  */
    F64 str1MeasVec1X;            /**< STR1 measured vector 1 X component (sensor frame)  */
    F64 str1MeasVec1Y;            /**< STR1 measured vector 1 Y component (sensor frame)  */
    F64 str1MeasVec1Z;            /**< STR1 measured vector 1 Z component (sensor frame)  */
    F64 str1MeasVec2X;            /**< STR1 measured vector 2 X component (sensor frame)  */
    F64 str1MeasVec2Y;            /**< STR1 measured vector 2 Y component (sensor frame)  */
    F64 str1MeasVec2Z;            /**< STR1 measured vector 2 Z component (sensor frame)  */
    F64 str1ModelVec0X;           /**< STR1 modelled vector 0 X component (IRC frame)  */
    F64 str1ModelVec0Y;           /**< STR1 modelled vector 0 Y component (IRC frame)  */
    F64 str1ModelVec0Z;           /**< STR1 modelled vector 0 Z component (IRC frame)  */
    F64 str1ModelVec1X;           /**< STR1 modelled vector 1 X component (IRC frame)  */
    F64 str1ModelVec1Y;           /**< STR1 modelled vector 1 Y component (IRC frame)  */
    F64 str1ModelVec1Z;           /**< STR1 modelled vector 1 Z component (IRC frame)  */
    F64 str1ModelVec2X;           /**< STR1 modelled vector 2 X component (IRC frame)  */
    F64 str1ModelVec2Y;           /**< STR1 modelled vector 2 Y component (IRC frame)  */
    F64 str1ModelVec2Z;           /**< STR1 modelled vector 2 Z component (IRC frame)  */
    F64 str1MeasQ0;               /**< STR1 measured quaternion Q0 (sensor to IRC frame)  */
    F64 str1MeasQ1;               /**< STR1 measured quaternion Q1 (sensor to IRC frame)  */
    F64 str1MeasQ2;               /**< STR1 measured quaternion Q2 (sensor to IRC frame)  */
    F64 str1MeasQ3;               /**< STR1 measured quaternion Q3 (sensor to IRC frame)  */
    U8 str1StarIdCount;           /**< STR1 number of identified stars  */
    U32 gnssTimeSeconds;          /**< GNSS Unix time integer seconds  (measurment unit is [s]) */
    U32 gnssTimeNs;               /**< GNSS Unix time fraction nanoseconds  (measurment unit is [ns]) */
    S32 gnssSatPosX;              /**< Satellite position vector X component (GNSS frame)  (measurment unit is [cm]) */
    S32 gnssSatPosY;              /**< Satellite position vector Y component (GNSS frame)  (measurment unit is [cm]) */
    S32 gnssSatPosZ;              /**< Satellite position vector Z component (GNSS frame)  (measurment unit is [cm]) */
    S32 gnssSatVelX;              /**< Satellite velocity vector X component (GNSS frame)  (measurment unit is [cm/s]) */
    S32 gnssSatVelY;              /**< Satellite velocity vector Y component (GNSS frame)  (measurment unit is [cm/s]) */
    S32 gnssSatVelZ;              /**< Satellite velocity vector Z component (GNSS frame)  (measurment unit is [cm/s]) */
    F32 extSensor0Float0;         /**< ExtSensor0 raw measurement float 0  (valid range is between -1000  and 1000 ) */
    F32 extSensor0Float1;         /**< ExtSensor0 raw measurement float 1  (valid range is between -1000  and 1000 ) */
    F32 extSensor0Float2;         /**< ExtSensor0 raw measurement float 2  (valid range is between -1000  and 1000 ) */
    F32 extSensor0Float3;         /**< ExtSensor0 raw measurement float 3  (valid range is between -1000  and 1000 ) */
    F32 extSensor0Float4;         /**< ExtSensor0 raw measurement float 4  (valid range is between -1000  and 1000 ) */
    F32 extSensor0Float5;         /**< ExtSensor0 raw measurement float 5  (valid range is between -1000  and 1000 ) */
    F32 extSensor1Float0;         /**< ExtSensor1 raw measurement float 0  (valid range is between -1000  and 1000 ) */
    F32 extSensor1Float1;         /**< ExtSensor1 raw measurement float 1  (valid range is between -1000  and 1000 ) */
    F32 extSensor1Float2;         /**< ExtSensor1 raw measurement float 2  (valid range is between -1000  and 1000 ) */
    F32 extSensor1Float3;         /**< ExtSensor1 raw measurement float 3  (valid range is between -1000  and 1000 ) */
    F32 extSensor1Float4;         /**< ExtSensor1 raw measurement float 4  (valid range is between -1000  and 1000 ) */
    F32 extSensor1Float5;         /**< ExtSensor1 raw measurement float 5  (valid range is between -1000  and 1000 ) */
    F32 rwl0SpeedMeas;            /**< RWL0 raw speed measurement  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl1SpeedMeas;            /**< RWL1 raw speed measurement  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl2SpeedMeas;            /**< RWL2 raw speed measurement  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    F32 rwl3SpeedMeas;            /**< RWL3 raw speed measurement  (measurment unit is [rpm]. valid range is between -12000 rpm and 12000 rpm) */
    Boolean fss0IsValid;          /**< FSS0 valid flag  */
    Boolean fss1IsValid;          /**< FSS1 valid flag  */
    Boolean fss2IsValid;          /**< FSS2 valid flag  */
    Boolean fss3IsValid;          /**< FSS3 valid flag  */
    Boolean cssIsValid;           /**< CSS valid flag  */
    Boolean mag0IsValid;          /**< MAG0 valid flag  */
    Boolean mag1IsValid;          /**< MAG1 valid flag  */
    Boolean gyro0IsValid;         /**< GYR0 valid flag  */
    Boolean gyro1IsValid;         /**< GYR1 valid flag  */
    Boolean hss0IsValid;          /**< HSS0 valid flag  */
    Boolean hss1IsValid;          /**< HSS1 valid flag  */
    Boolean str0IsValid;          /**< STR0 valid flag  */
    Boolean str1IsValid;          /**< STR1 valid flag  */
    Boolean gnssIsValid;          /**< GNSS valid flag  */
    Boolean gnssIsNew;            /**< GNSS new flag  */
    Boolean extSensor0IsValid;    /**< ExtSensor0 valid flag  */
    Boolean extSensor1IsValid;    /**< ExtSensor1 valid flag  */
    Boolean rwl0IsValid;          /**< RWL0 valid flag  */
    Boolean rwl1IsValid;          /**< RWL1 valid flag  */
    Boolean rwl2IsValid;          /**< RWL2 valid flag  */
    Boolean rwl3IsValid;          /**< RWL3 valid flag  */
} TypesCubeComputerControlProgram8_SimSensorRaw;

/**
 * @brief Reference RPY values message structure
 * @details Reference roll, pitch and yaw values for 3-axis wheel control
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ReferenceRpyStruct {
    F32 cmdRpyRoll;     /**< RPY Roll command  (measurment unit is [deg]. valid range is between -180 deg and 180 deg) */
    F32 cmdRpyPitch;    /**< RPY Pitch command  (measurment unit is [deg]. valid range is between -180 deg and 180 deg) */
    F32 cmdRpyYaw;      /**< RPY Yaw command  (measurment unit is [deg]. valid range is between -180 deg and 180 deg) */
} TypesCubeComputerControlProgram8_ReferenceRpy;

/**
 * @brief Reference LLH target command message structure
 * @details Reference target location for ground and target tracking controller
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ReferenceTargetStruct {
    F32 cmdTargetLatitude;     /**< Target latitude command  (measurment unit is [deg]. valid range is between -90 deg and 90 deg) */
    F32 cmdTargetLongitude;    /**< Target longitude command  (measurment unit is [deg]. valid range is between -180 deg and 180 deg) */
    F32 cmdTargetAltitude;     /**< Target altitude command  (measurment unit is [km]. valid range is between -1000 km and 1000000 km) */
} TypesCubeComputerControlProgram8_ReferenceTarget;

/**
 * @brief Reference IRC vector message structure
 * @details Reference IRC vector for inertial target tracking controller
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ReferenceIrcVectorStruct {
    F32 cmdEciVecX;    /**< Commanded ECI pointing vector X component  (valid range is between -1  and 1 ) */
    F32 cmdEciVecY;    /**< Commanded ECI pointing vector Y component  (valid range is between -1  and 1 ) */
    F32 cmdEciVecZ;    /**< Commanded ECI pointing vector Z component  (valid range is between -1  and 1 ) */
} TypesCubeComputerControlProgram8_ReferenceIrcVector;

/**
 * @brief Reference parameters for FMC scan message structure
 * @details Reference parameters for FMC scan
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_ReferenceFmcParamStruct {
    TypesCubeComputerControlProgram8_FmcFactor cmdFmcFactor;    /**< FMC Scanning Factor  */
    F32 cmdFmcRoll;                                             /**< RPY Roll command  (measurment unit is [deg]. valid range is between -180 deg and 180 deg) */
    U32 cmdFmcUnixSeconds;                                      /**< Unix time seconds at FMC target centre  (measurment unit is [s]) */
    U32 cmdFmcUnixNs;                                           /**< Unix time nanoseconds at FMC target centre  (measurment unit is [ns]) */
} TypesCubeComputerControlProgram8_ReferenceFmcParam;

/**
 * @brief Mag Deploy Command message structure
 * @details Deploy Magnetometer
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_DeployCommandMagStruct {
    Boolean deployMag0;    /**< Deploy MAG0  */
    Boolean deployMag1;    /**< Deploy MAG1  */
} TypesCubeComputerControlProgram8_DeployCommandMag;

/**
 * @brief CubeNode-Quad PortMap message structure
 * @details The configured port map of all CubeNode-Quads
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_CubeNodePortMapStruct {
    TypesCommonFrameworkTypes1_NodeType nodeTypeSlot0;       /**< CubeNode-Quad node type for this port map (CQ0)  */
    U32 serialIntSlot0;                                      /**< CubeNode-Quad serial number integer for this port map (CQ0)  */
    TypesCubeComputerControlProgram8_CqAssign port1Slot0;    /**< Abstract type assignment on port 1 of this CubeNode-Quad (CQ0)  */
    TypesCubeComputerControlProgram8_CqAssign port2Slot0;    /**< Abstract type assignment on port 2 of this CubeNode-Quad (CQ0)  */
    TypesCubeComputerControlProgram8_CqAssign port3Slot0;    /**< Abstract type assignment on port 3 of this CubeNode-Quad (CQ0)  */
    TypesCubeComputerControlProgram8_CqAssign port4Slot0;    /**< Abstract type assignment on port 4 of this CubeNode-Quad (CQ0)  */
    TypesCommonFrameworkTypes1_NodeType nodeTypeSlot1;       /**< CubeNode-Quad node type for this port map (CQ1)  */
    U32 serialIntSlot1;                                      /**< CubeNode-Quad serial number integer for this port map (CQ1)  */
    TypesCubeComputerControlProgram8_CqAssign port1Slot1;    /**< Abstract type assignment on port 1 of this CubeNode-Quad (CQ1)  */
    TypesCubeComputerControlProgram8_CqAssign port2Slot1;    /**< Abstract type assignment on port 2 of this CubeNode-Quad (CQ1)  */
    TypesCubeComputerControlProgram8_CqAssign port3Slot1;    /**< Abstract type assignment on port 3 of this CubeNode-Quad (CQ1)  */
    TypesCubeComputerControlProgram8_CqAssign port4Slot1;    /**< Abstract type assignment on port 4 of this CubeNode-Quad (CQ1)  */
    TypesCommonFrameworkTypes1_NodeType nodeTypeSlot2;       /**< CubeNode-Quad node type for this port map (CQ2)  */
    U32 serialIntSlot2;                                      /**< CubeNode-Quad serial number integer for this port map (CQ2)  */
    TypesCubeComputerControlProgram8_CqAssign port1Slot2;    /**< Abstract type assignment on port 1 of this CubeNode-Quad (CQ2)  */
    TypesCubeComputerControlProgram8_CqAssign port2Slot2;    /**< Abstract type assignment on port 2 of this CubeNode-Quad (CQ2)  */
    TypesCubeComputerControlProgram8_CqAssign port3Slot2;    /**< Abstract type assignment on port 3 of this CubeNode-Quad (CQ2)  */
    TypesCubeComputerControlProgram8_CqAssign port4Slot2;    /**< Abstract type assignment on port 4 of this CubeNode-Quad (CQ2)  */
    TypesCommonFrameworkTypes1_NodeType nodeTypeSlot3;       /**< CubeNode-Quad node type for this port map (CQ3)  */
    U32 serialIntSlot3;                                      /**< CubeNode-Quad serial number integer for this port map (CQ3)  */
    TypesCubeComputerControlProgram8_CqAssign port1Slot3;    /**< Abstract type assignment on port 1 of this CubeNode-Quad (CQ3)  */
    TypesCubeComputerControlProgram8_CqAssign port2Slot3;    /**< Abstract type assignment on port 2 of this CubeNode-Quad (CQ3)  */
    TypesCubeComputerControlProgram8_CqAssign port3Slot3;    /**< Abstract type assignment on port 3 of this CubeNode-Quad (CQ3)  */
    TypesCubeComputerControlProgram8_CqAssign port4Slot3;    /**< Abstract type assignment on port 4 of this CubeNode-Quad (CQ3)  */
} TypesCubeComputerControlProgram8_CubeNodePortMap;

/**
 * @brief File Transfer Setup message structure
 * @details Setup a file transfer
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_FileTransferSetupStruct {
    TypesCubeComputerControlProgram8_FtpOpCode opCode;      /**< Operation to perform  */
    TypesCubeComputerControlProgram8_FtpFiles file;         /**< File to target  */
    TypesCommonFrameworkTypes1_NodeType node;               /**< OpCode = Upgrade: Node to upgrade in conjunction with SerialInt  */
    U32 serialInt;                                          /**< OpCode = Upgrade: Serial Number Integer of node to upgrade in conjunction with Node  */
    TypesCommonFrameworkTypes1_ProgramType program;         /**< OpCode = Upgrade: The Program Type to upgrade with  */
    U32 fileSize;                                           /**< Size of target file: Only used to confirm setup.  (measurment unit is [Bytes]) */
    TypesCubeComputerControlProgram8_NodePort forcePort;    /**< OpCode = Upgrade: Force that the node on this port is upgraded In the event that the node is not discoverable.  (valid range is between 0  and 5 ) */
    U8 metaData[128];                                       /**< CubeSpace File Meta Data. May be less than allocated size (padding required)  */
} TypesCubeComputerControlProgram8_FileTransferSetup;

/**
 * @brief File Transfer Status message structure
 * @details File Transfer Status
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_FileTransferStatusStruct {
    TypesCubeComputerControlProgram8_FtpState state;                  /**< FTP Global State  */
    TypesCubeComputerControlProgram8_FtpUpgradeState upgradeState;    /**< FTP Internal Upgrade State  */
    U32 dataRemain;                                                   /**< Amount of remaining data to transfer  (measurment unit is [Bytes]) */
    U32 errorCode;                                                    /**< Operation Error Code. Non-Zero = ERROR  */
    Boolean busyError;                                                /**< Bootloader is busy  */
    Boolean fileMetaError;                                            /**< File Metadata received is invalid  */
    Boolean versionError;                                             /**< File version is incompatible  */
    Boolean nodeExistError;                                           /**< Target node does not exist  */
    Boolean nodeExpectError;                                          /**< Target node is not expected  */
    Boolean fileCrcError;                                             /**< File CRC Error Flag  */
    Boolean fileSizeError;                                            /**< File is too large  */
    Boolean fileError;                                                /**< File Error Flag (open/close)  */
    Boolean fileInvalidError;                                         /**< File Invalid Error Flag  */
    Boolean fileFullError;                                            /**< File Full Error Flag  */
    Boolean fileEmptyError;                                           /**< File Empty Error Flag  */
    Boolean readError;                                                /**< Read Error Flag  */
    Boolean writeError;                                               /**< Write Error Flag  */
    Boolean eraseError;                                               /**< Erase Error Flag  */
    Boolean frameSizeError;                                           /**< Frame Size Error Flag  */
    Boolean timeoutError;                                             /**< Timeout Error Flag  */
    Boolean nodeCommsError;                                           /**< Node comms fails during upgrade  */
    Boolean nodeUsedError;                                            /**< Node is required for control  */
} TypesCubeComputerControlProgram8_FileTransferStatus;

/**
 * @brief File Info message structure
 * @details Cached file information after calling FileTransferSetup
 */
typedef struct TCTLM_PACKED TypesCubeComputerControlProgram8_FileInfoStruct {
    TypesCubeComputerControlProgram8_FtpFiles file;         /**< File this info represents  */
    TypesCubeComputerControlProgram8_FtpBackend backend;    /**< Which storage medmium is the file in  */
    TypesCubeComputerControlProgram8_FtpFileType type;      /**< File Type  */
    U32 size;                                               /**< File Size (actual data written)  (measurment unit is [Bytes]) */
    U32 allocSize;                                          /**< Size of memory allocated to file  (measurment unit is [Bytes]) */
    U32 vectTblOffset;                                      /**< Vector Table Offset: Onling applicable to application binary files  (measurment unit is [Bytes]) */
    U32 unixTimeSeconds;                                    /**< Modification Unix time s  (measurment unit is [s]) */
    U32 unixTimeNanoSeconds;                                /**< Modification Unix time ns  (measurment unit is [ns]. valid range is between 0 ns and 999999999 ns) */
    U32 crc;                                                /**< File CRC  */
    Text component[32];                                     /**< ASCII string of chars denoting the CubeSpace Component this file is for/from  */
    Text program[32];                                       /**< ASCII string of chars denoting the Component Application this file is for/from  */
    U8 firmwareMajorVersion;                                /**< Firmware version (Major) that this file is for/from  */
    U8 firmwareMinorVersion;                                /**< Firmware version (Minor) that this file is for/from  */
    U16 firmwarePatchVersion;                               /**< Firmware version (Patch) that this file is for/from  */
    U8 systemMajorVersion;                                  /**< System version (Major) that this file is for/from  */
    U8 systemMinorVersion;                                  /**< System version (Minor) that this file is for/from  */
    U16 systemPatchVersion;                                 /**< System version (Patch) that this file is for/from  */
    TypesCommonFrameworkTypes1_NodeType ownerNodeType;      /**< The Node Type that owns the file  */
    U32 ownerSerialInt;                                     /**< The Serial Number integer of the node that owns the file  */
    TypesCommonFrameworkTypes1_ProgramType ownerProgram;    /**< The Program Type that owns the file  */
} TypesCubeComputerControlProgram8_FileInfo;

/*******************************************************************************
 *****************************   PROTOTYPES   **********************************
 ******************************************************************************/

#ifdef __cplusplus
}
#endif

#endif // TYPES_CUBE_COMPUTER_CONTROL_PROGRAM_8_H
