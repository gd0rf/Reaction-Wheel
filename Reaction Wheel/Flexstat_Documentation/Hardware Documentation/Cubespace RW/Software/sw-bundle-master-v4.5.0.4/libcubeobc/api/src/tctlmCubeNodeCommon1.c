/************************************************************************************
 * This file was auto-generated by CIDEA                           .                *
 * Please do not modify the contents of this file manually.                         *
 ***********************************************************************************/

#include <cubeObc/cubeObc_typeDef.h>
#include <cubeObc/cubeObc_errorDef.h>
#include <cubeObc/cubeObc_tctlmCommsMasterSvc.h>
#include "tctlmCubeNodeCommon1.h"

/*******************************************************************************
 ***************************  GLOBAL MACROS   **********************************
 ******************************************************************************/

/*******************************************************************************
 **************************   GLOBAL FUNCTIONS   *******************************
 ******************************************************************************/

 /* SET functions */

ErrorCode tctlmCubeNodeCommon1_setPowerSwitchState(TypeDef_TctlmEndpoint *endpoint, TypesCubeNodeCommon1_PowerSwitchState *setVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 127;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 4)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare0 = ((setVal->power[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_1].power & 0xFF) << 0);
        MEMCPY(&buffer[0], &prepare0, sizeof(U8));
        /*************************/
        U8 prepare1 = ((setVal->power[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_2].power & 0xFF) << 0);
        MEMCPY(&buffer[1], &prepare1, sizeof(U8));
        /*************************/
        U8 prepare2 = ((setVal->power[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_3].power & 0xFF) << 0);
        MEMCPY(&buffer[2], &prepare2, sizeof(U8));
        /*************************/
        U8 prepare3 = ((setVal->power[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_4].power & 0xFF) << 0);
        MEMCPY(&buffer[3], &prepare3, sizeof(U8));
        /*************************/
        bufferSizeUsed = 4;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    return result;
}


 /* GET functions */

ErrorCode tctlmCubeNodeCommon1_getNodeModel(TypeDef_TctlmEndpoint *endpoint, TypesCubeNodeCommon1_NodeModel *returnVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 252;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 1)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        bufferSizeUsed = 0;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        if (bufferSizeUsed != 1)
        {
            result = CUBEOBC_ERROR_TLM_SIZE;
        }
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare0;
        MEMCPY(&prepare0, &buffer[0], sizeof(U8));
        returnVal->model = (TypesCubeNodeCommon1_NodeModelEnum)((prepare0 >> 0) & 0xFF);
    }
    /*************************/

    return result;
}

ErrorCode tctlmCubeNodeCommon1_getPowerSwitchState(TypeDef_TctlmEndpoint *endpoint, TypesCubeNodeCommon1_PowerSwitchState *returnVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 253;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 4)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        bufferSizeUsed = 0;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        if (bufferSizeUsed != 4)
        {
            result = CUBEOBC_ERROR_TLM_SIZE;
        }
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare0;
        MEMCPY(&prepare0, &buffer[0], sizeof(U8));
        returnVal->power[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_1].power = (TypesCubeNodeCommon1_SwitchState)((prepare0 >> 0) & 0xFF);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare1;
        MEMCPY(&prepare1, &buffer[1], sizeof(U8));
        returnVal->power[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_2].power = (TypesCubeNodeCommon1_SwitchState)((prepare1 >> 0) & 0xFF);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare2;
        MEMCPY(&prepare2, &buffer[2], sizeof(U8));
        returnVal->power[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_3].power = (TypesCubeNodeCommon1_SwitchState)((prepare2 >> 0) & 0xFF);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare3;
        MEMCPY(&prepare3, &buffer[3], sizeof(U8));
        returnVal->power[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_4].power = (TypesCubeNodeCommon1_SwitchState)((prepare3 >> 0) & 0xFF);
    }
    /*************************/

    return result;
}

ErrorCode tctlmCubeNodeCommon1_getHealthTlm(TypeDef_TctlmEndpoint *endpoint, TypesCubeNodeCommon1_HealthTlm *returnVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 254;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 26)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        bufferSizeUsed = 0;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        if (bufferSizeUsed != 26)
        {
            result = CUBEOBC_ERROR_TLM_SIZE;
        }
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuCurrent, &buffer[0], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuTemp, &buffer[2], sizeof(S16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuVoltage, &buffer[4], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->pmuCurrent, &buffer[6], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare4;
        MEMCPY(&prepare4, &buffer[8], sizeof(U8));
        returnVal->pmuCurrentValid = (Boolean)((prepare4 >> 0) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare5;
        MEMCPY(&prepare5, &buffer[8], sizeof(U8));
        returnVal->powerGood = (Boolean)((prepare5 >> 1) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->portCurrent[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_1].vBattCurrent, &buffer[9], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare8;
        MEMCPY(&prepare8, &buffer[11], sizeof(U8));
        returnVal->portCurrent[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_1].vBattOvercurrent = (Boolean)((prepare8 >> 0) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->portCurrent[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_2].vBattCurrent, &buffer[12], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare10;
        MEMCPY(&prepare10, &buffer[14], sizeof(U8));
        returnVal->portCurrent[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_2].vBattOvercurrent = (Boolean)((prepare10 >> 0) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->portCurrent[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_3].vBattCurrent, &buffer[15], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare12;
        MEMCPY(&prepare12, &buffer[17], sizeof(U8));
        returnVal->portCurrent[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_3].vBattOvercurrent = (Boolean)((prepare12 >> 0) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->portCurrent[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_4].vBattCurrent, &buffer[18], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare14;
        MEMCPY(&prepare14, &buffer[20], sizeof(U8));
        returnVal->portCurrent[TYPES_CUBE_NODE_COMMON_TYPES_1__PORT_4].vBattOvercurrent = (Boolean)((prepare14 >> 0) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(returnVal->watchdogCount, &buffer[21], 5);
    }
    /*************************/

    return result;
}

